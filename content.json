{"pages":[{"title":"Engine","text":"","link":"/Engine/index.html"},{"title":"Language","text":"","link":"/Language/index.html"},{"title":"Rendering","text":"","link":"/Rendering/index.html"},{"title":"Tool","text":"","link":"/Tool/index.html"},{"title":"","text":"联系方式 手机: Email: lonelywaitinggm@gmail.com 微信: 个人信息 刘腾/男/1995/09 本科/江南大学/数字媒体技术系/2012-2016 工作年限: 2016~至今 工作经历上海烛龙(2016/01-2018/10)古剑奇谭网络版 模块 职责 地形 维护并实现新功能,如LOD,路面工具,地形缩减,高度图相关编辑等等 角色自定义 捏脸,化妆,换装,换肤等 角色表情系统 制作工具链开发,导入导出,编辑器,Runtime,口型分析生成等 角色动画 维护,优化以及新功能实现 米哈游(2018/11-2020/09)ProjectX 模块 职责 星球过程式生成 使用噪声系统实现星球外观过程式生成 星球工具链开发 在UE4中实现一套编辑器用于星球预览与编辑 平面关卡上球的改造 分离平面关卡与星球，使其二者无缝衔接 GPU异步回读 使用DX11的Query实现地形高度的回读给植被系统使用 星穹铁道 Unity引擎开发，负责渲染开发，性能优化 莉莉丝(2020/9月-至今)Dislyte(2020/09-2023/02) UE引擎开发，负责渲染开发，性能优化，打包构建，平台兼容等工作| 模块 | 职责 || :—-: | :—- || 性能优化 | UI合批&amp;剔除优化，渲染线程优化，IOS半精度支持，Shader变种优化等等 || 渲染开发 | 阴影效果定制，定制后处理表现，渲染管线改造等 || 打包构建 | 搭建基于Jenkins的引擎构建工具链，IOS远程构建流程构建，Android/IOS打包脚本实现与维护等 || 工具开发 | PSO收集工具，图集生成工具，C++ HotFix工具，资源快速热更工具等 || 平台兼容 | Android/IOS兼容性，宽屏分辨率适配等 || 疑难问题 | 各类疑难bug修复等 | 引擎中台(2023/02-至今) 基于UE4引擎的Switch平台构建，PC性能及特性支持，疑难杂症处理 模块 职责 性能优化 Lightmap显存/性能优化，IOS半精度支持等 Switch平台 构建工具链，Crash Report流程，渲染管线跑通，添加FP16支持等 PC平台 性能优化，DirectX 12支持，VRS等 疑难问题 卡顿，DPI，多开等 技能清单 C++，Python UnrealEngine Git, P4 Rendering Android/IOS 自我评价 热衷底层技术 热爱学习，喜欢看书 阅读英文论文没有任何问题","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"","text":"body { counter-reset: body; /* 修改正文字体 */ font-family: &quot;Vollkorn&quot;, Palatino, Times; color: #333; line-height: 1.4; text-align: justify; } /* 正文标题自动序号 */ h1 { counter-reset: h1; } h2 { counter-reset: h2; } h3 { counter-reset: h3; } h4 { counter-reset: h4; } h5 { counter-reset: h5; } h6 { counter-reset: h6; } h1:before { counter-increment: body; content: counter(body) &quot;. &quot;; } h2:before { counter-increment: h1; content: counter(body) &quot;.&quot; counter(h1) &quot;. &quot;; } h3:before { counter-increment: h2; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2) &quot;. &quot;; } h4:before { counter-increment: h3; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3) &quot;. &quot;; } h5:before { counter-increment: h4; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4) &quot;. &quot;; } h6:before { counter-increment: h5; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4)&quot;.&quot; counter(h5) &quot;. &quot;; } h3.md-focus:before { counter-increment: h2; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2) &quot;. &quot;; } h4.md-focus:before { counter-increment: h3; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3) &quot;. &quot;; } h5.md-focus:before { counter-increment: h4; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4) &quot;. &quot;; } h6.md-focus:before { counter-increment: h5; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4)&quot;.&quot; counter(h5) &quot;. &quot;; } h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before { color: #333; border: unset; border-radius: unset; position: unset; left: unset; top: unset; float: unset; font-size: unset; padding-left: unset; padding-right: unset; vertical-align: unset; font-weight: unset; line-height: unset; } .sidebar-content { counter-reset: h1 } .outline-h1 { counter-reset: h2 } .outline-h2 { counter-reset: h3 } .outline-h3 { counter-reset: h4 } .outline-h4 { counter-reset: h5 } .outline-h5 { counter-reset: h6 } .outline-h1&gt;.outline-item&gt;.outline-label:before { counter-increment: h1; content: counter(h1) &quot;. &quot; } .outline-h2&gt;.outline-item&gt;.outline-label:before { counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot; } .outline-h3&gt;.outline-item&gt;.outline-label:before { counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot; } .outline-h4&gt;.outline-item&gt;.outline-label:before { counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot; } .outline-h5&gt;.outline-item&gt;.outline-label:before { counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot; } .outline-h6&gt;.outline-item&gt;.outline-label:before { counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot; } /* TOC 自动序号 */ .md-toc-inner { text-decoration: none; } .md-toc-content { counter-reset: h1toc } .md-toc-h1 { margin-left: 0; counter-reset: h2toc } .md-toc-h2 { margin-left: 1rem; counter-reset: h3toc } .md-toc-h3 { margin-left: 2rem; counter-reset: h4toc } .md-toc-h4 { margin-left: 3rem; counter-reset: h5toc } .md-toc-h5 { margin-left: 4rem; counter-reset: h6toc } .md-toc-h6 { margin-left: 5rem; } .md-toc-h1:before { counter-increment: h1toc; content: counter(h1toc) &quot; &quot; } .md-toc-h2:before { counter-increment: h2toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; } .md-toc-h3:before { counter-increment: h3toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; } .md-toc-h4:before { counter-increment: h4toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; } .md-toc-h5:before { counter-increment: h5toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot; } .md-toc-h6:before { counter-increment: h6toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot; counter(h6toc) &quot;. &quot; } .md-toc-h1 .md-toc-inner { margin-left: 0; } .md-toc-h2 .md-toc-inner { margin-left: 0; } .md-toc-h3 .md-toc-inner { margin-left: 0; } .md-toc-h4 .md-toc-inner { margin-left: 0; } .md-toc-h5 .md-toc-inner { margin-left: 0; } .md-toc-h6 .md-toc-inner { margin-left: 0; }","link":"/resources/css/自定义博客显示/base.user.css"}],"posts":[{"title":"","text":"CSM Cache该方案的实现核心在于 由于CSM记录的深度信息是上一帧的，因此比较深度时应该将当前场景的深度转到上一帧，保持同一空间 应当保存上一帧WorldToLight矩阵，替代当帧的WorldToLight矩阵","link":"/CSM Cache/"},{"title":"Color and Radiometry","text":"可见光人眼的可见光波谱范围约为370nm~730nm 蓝光：400nm,绿光：550nm,红光：650nm 光谱表示SPD(spectral power distribution): 光谱功率分布 SPD是一个关于波长的函数，通常是做法是找到一组基函数，用于将无限维度的SPD映射到低纬度空间表示 12345678template&lt;int nSamples&gt;class CoefficientSpecturm{public: &lt;CoefficientSpecturm public method&gt;protected: &lt;CoefficientSpecturm protected data&gt;}; 12&lt;CoefficientSpecturm protected data&gt; = float c[nSamples]; 接下来介绍两种常用的表示方法 SampleSpectrum这种方法是将光谱重新均匀采样来进行拟合 考虑波长为400nm~700nm的可见光，可以将区间分为N段，以30段为例，通常足以拟合比较复杂的光谱数据 12345678910111213&lt;Spectrum Utility Declarations&gt; = static const int sampledLambdaStart = 370; static const int sampledLambdaEnd = 700; static const int nSpectralSamples = 30;&lt;Spectrum Declarations&gt; = class SampledSpectrum : public CoefficientSpectrum&lt;nSpectralSamples&gt; { public: &lt;SampledSpectrum public Methods&gt; private: &lt;SampledSpectrum Private Data&gt; }; 那么如何从一组光谱数据来构造光谱表示? 假设现在有一组光谱数据$(\\lambda_i,v_i)$，表示第$i$个采样点的波长为$\\lambda_i$，值为$v_i$,这些采样点往往分布不均匀 对于给定的一组光谱数据，可以构造出相应的折线图 然后将此折线图划分为30个区域，如上图：[400,410) , [410,420)….[690,700) 计算每个区域覆盖的面积和，求其平均值，得到新的采样值 12345678910static SampledSpectrum FromSampled(const float* lambda , const float* v , int n){ &lt;Sort samples if unordered, use sorted for returned spectrum&gt; SampledSpectrum r; for(int i = 0; i &lt; nSpectralSamples; i++) { &lt;Compute average value of given SPD over ith sample&apos;s range&gt; }} 12345&lt;Compute average value of given SPD over ith sample&apos;s range&gt;= // compute ith sample&apos;s range float lambda0 = Lerp(float(i) / float(nSpectralSamples) , sampledLambdaStart , sampledLambdaEnd); float lambda1 = Lerp(float(i+1) / float(nSpectralSamples) , sampledLambdaStart , sampledLambdaEnd); r.c[i] = AverageSpectrumSamples(lambda, v, n, lambda0, lambda1); 1234567891011&lt;Spectrum Method Definitions&gt; = float AverageSpectrumSamples(const float* lambda , const float* vals , int n , float lambdaStart , float lambdaEnd) { &lt;handles case with out-of bounds range or single sample only&gt; float sum = 0.0f; &lt;Add contribute of constant segments before/after samples&gt; &lt;Advance to first relevant wavelength , segment&gt; &lt;Loop over wavelength sample segments and add contributes&gt; return sum / (lambdaEnd - lanbdaStart); } 处理边界条件：数据的波长范围全部处于区间之外，或者原始数据只有一个采样点 1234&lt;handles case with out-of bounds range or single sample only&gt; = if(lambdaEnd &lt;= lambda[0]) return lambda[0]; if(lambdaStart &gt;= lambda[n - 1]) return lambda[n - 1]; if(n == 1) return lambda[0]; 对于处于数据之外的区域，将其值视为常量,即区域为方形 12345&lt;Add contribute of constant segments before/after samples&gt; = if(lambdaStart &lt; lambda[0]) sum += vals[0] * (lambda[0] - lambdaStart); if(lambdaEnd &gt; lambda[n - 1]) sum += vals[n - 1] * (lambdaEnd - lambda[n - 1]); 找到区间起始波长所在的数据段 123&lt;Advance to first relevant wavelength , segment&gt; = int i = 0; while(lambdaStart &gt; lambeda[i+1]) ++i; 计算区域覆盖的梯形面积和 123456789101112&lt;Loop over wavelength sample segments and add contributes&gt; #define INTERP(w,i)\\ Lerp(((w) - lambda[(i)]) / (lambda[(i) + 1] - lambda[(i)]) , vals[(i)] , vals[(i) + 1]) #define SEG_AVG(wl0,wl1,i) (0.5f * (INTERP(wl0,i) + INTERP(wl1,i))) for(; i+1 &lt; n &amp;&amp; lambdaEnd &gt;= lambda[i]; i++) { float segStart = max(lambdaStart , lambda[i]); float segEnd = min(lambdaEnd , lambda[i+1]); sum += SEG_AVG(segStart,segEnd,i) * (segEnd - segStart); } #undef INTERP #undef SEG_AVG 经过以上步骤，将光谱数据拟合为线性分段函数，然而，最终我们需要将光谱转化为RGB才能在显示器上显示出来 三色刺激理论认为所有人眼可视的SPD都可以精确的使用三个值$(x_\\lambda,y_\\lambda,z_\\lambda)$表示,公式如下： $$x_\\lambda = \\frac{1}{\\int Y(\\lambda)d\\lambda}\\int_\\lambda S(\\lambda)X(\\lambda)d\\lambda$$ $$y_\\lambda = \\frac{1}{\\int Y(\\lambda)d\\lambda}\\int_\\lambda S(\\lambda)Y(\\lambda)d\\lambda$$ $$z_\\lambda = \\frac{1}{\\int Y(\\lambda)d\\lambda}\\int_\\lambda S(\\lambda)Z(\\lambda)d\\lambda$$ $X(\\lambda),Y(\\lambda),Z(\\lambda)$为光谱匹配曲线,是由国际照明委员会经过一系列实验制定的. 这三条曲线被认为与人类视网膜的三种感色视椎体细胞响应类似 两个由多种不同波长的光混合而成的光源可以表现出同样的颜色，这叫做“异谱同色”(metamerism) 尽管对于人类观察者而言，XYZ可以很好的表示SPD，然而对于光谱计算并不是一种好的方案 XYZ的乘积与SPD的乘积再计算得到的XYZ相差很大 在SampledSpectrum中，SPD将会被变换重采样进行降维，因此，光谱匹配曲线也需要在重采样到相同维度才能进行运算 123456&lt;Spectral Data Declarations&gt; = static const int nCIESamples = 471; extern const float CIE_X[nCIESamples]; extern const float CIE_Y[nCIESamples]; extern const float CIE_Z[nCIESamples]; extern const float CIE_lambda[nCIESamples]; CIE_lambda中记录的是每个采样点的波长，这里使用1nm为步长，CIE_X,Y,Z记录从360nm~830nm的光谱匹配曲线采样点 123&lt;SampledSpectrum Private Data&gt; = static SampledSpectrum X , Y , Z; static float yInt; 由于光谱匹配曲线是固定的，因此使用static变量 XYZ匹配曲线计算放在初始化函数中，当程序启动时进行调用 123456&lt;SampledSpectrum Public Methods&gt; += static void Init() { &lt;Compute XYZ matching functions for SampledSpectrum&gt; &lt;Compute RGB to spectrum functions for SampledSpectrum&gt; } 12345678910&lt;Compute XYZ matching functions for SampledSpectrum&gt; = for(int i = 0; i &lt; nSpectralSamples; i++) { float wl0 = Lerp(float(i) / float(nSpectrualSamples) , sampledLambdaStart , sampledLambdaEnd); float wl1 = Lerp(float(i+1) / float(nSpectrualSamples) , sampledLambdaStart , sampledLambdaEnd); X.c[i] = AverageSpectrumSamples(CIE_lambda, CIE_X, nCIESamples, wl0, wl1); Y.c[i] = AverageSpectrumSamples(CIE_lambda, CIE_Y, nCIESamples, wl0, wl1); Z.c[i] = AverageSpectrumSamples(CIE_lambda, CIE_Z, nCIESamples, wl0, wl1); yInt += Y.c[i]; } 现在我们有了XYZ匹配曲线的重采样数据，公式可以转化为用黎曼和表示: $$x_\\lambda \\approx \\frac{1} {\\int Y(\\lambda)d\\lambda} \\sum_i X_i c_i$$ $$y_\\lambda \\approx \\frac{1} {\\int Y(\\lambda)d\\lambda} \\sum_i Y_i c_i$$ $$z_\\lambda \\approx \\frac{1} {\\int Y(\\lambda)d\\lambda} \\sum_i Z_i c_i$$ 123456789101112131415&lt;SampledSpectrum Public Methods&gt; += void ToXYZ(float xyz[3]) const { xyz[0] = xyz[1] = xyz[2] = 0.0f; for(int i = 0; i &lt; nSpectralSamples; i++) { xyz[0] += X.c[i] * c[i]; xyz[1] += Y.c[i] * c[i]; xyz[2] += Z.c[i] * c[i]; } xyz[9] /= yInt; xyz[1] /= yInt; xyz[2] /= yInt; } XYZ中的y与亮度密切相关. 12345678910&lt;SampledSpectrum public Methods&gt; += float y() const { float yy = 0.0f; for(int i = 0; i &lt; nSpectralSamples; i++) { yy += Y.c[i] * c[i]; } return yy / yInt; } 现在我们已经将SPD转换为了XYZ,那么如何将XYZ转化为RGB用于显示呢？ 当我们将RGB显示在显示器上时，真实显示的光谱主要由三色光谱响应曲线的加权和确定.，由发光材料决定 LED,LCD,以及等离子体的三色光谱响应曲线不同，因此相同的SPD,在这三种情况下显示出来的RGB是不同的. 在LCD,LED显示RGB(0.6,0.3,0.2)的光谱分别如下图所示： 可见SPD相差很大.因此，RGB作为颜色只在知道显示器属性的情况下才是有意义的. 给定一个SPD的$x_{\\lambda},y_\\lambda,z_\\lambda$ 在给定显示器的情况下,也就是给定三色光谱响应曲线$$R(\\lambda),G(\\lambda),B(\\lambda)$$ RGB按照如下公式计算所得： $$\\begin{align}r = \\int R(\\lambda)S(\\lambda)d\\lambda &amp;= \\int R(\\lambda)(x_\\lambda X(\\lambda) + y_\\lambda Y(\\lambda) + z_\\lambda Z(\\lambda))d\\lambda \\notag\\\\ &amp;=x_\\lambda \\int R(\\lambda)X(\\lambda)d\\lambda + y_\\lambda \\int R(\\lambda)Y(\\lambda)d\\lambda + z_\\lambda \\int R(\\lambda) Z(\\lambda)d\\lambda\\notag\\end{align}$$ $$\\begin{bmatrix} r \\\\ g \\\\ b\\end{bmatrix}=\\begin{bmatrix} \\int R(\\lambda)X(\\lambda)d\\lambda &amp; \\int R(\\lambda)Y(\\lambda)d\\lambda &amp; \\int R(\\lambda)Z(\\lambda)d\\lambda\\\\ \\int G(\\lambda)X(\\lambda)d\\lambda &amp; \\int G(\\lambda)Y(\\lambda)d\\lambda &amp; \\int G(\\lambda)Z(\\lambda)d\\lambda \\\\ \\int B(\\lambda)X(\\lambda)d\\lambda &amp; \\int B(\\lambda)Y(\\lambda)d\\lambda &amp; \\int B(\\lambda)Z(\\lambda)d\\lambda\\end{bmatrix}\\begin{bmatrix} x_\\lambda \\\\ y_\\lambda \\\\ z_\\lambda\\end{bmatrix}$$ 对于高清电视而言：$$\\begin{bmatrix} r \\\\ g \\\\ b\\end{bmatrix} =\\begin{bmatrix} 3.240479 &amp; -1.537150 &amp; -0.498535\\\\ -0.969256 &amp; 1.875991 &amp; 0.041556 \\\\ 0.055648 &amp; -0.204043 &amp; 1.057311\\end{bmatrix}\\begin{bmatrix} x_\\lambda \\\\ y_\\lambda \\\\ z_\\lambda\\end{bmatrix}$$ 计算得到的RGB是在linear space,需要Gamma矫正才能变换到sRGB空间 1234567&lt;Spectrum Utility Declarations&gt; += inline void XYZToRGB(const float xyz[3] , float rgb[3]) { rgb[0] = 3.240479 * xyz[0] - 1.537150 * xyz[1] - 0.498535 * xyz[2]; rgb[1] =-0.969256 * xyz[0] + 1.875991 * xyz[1] + 0.041556 * xyz[2]; rgb[2] = 0.055648 * xyz[0] - 0.204043 * xyz[1] + 1.057311 * xyz[2]; } 逆矩阵可以将RGB转为XYZ 1234567&lt;Spectrum Utility Declarations&gt; += inline void RGBToXYZ(const float rgb[3], float xyz[3]) { xyz[0] = 0.412453 * rgb[0] + 0.357580 * rgb[1] + 0.180423 * rgb[2]; xyz[1] = 0.212671 * rgb[0] + 0.715160 * rgb[1] + 0.072169 * rgb[2]; xyz[2] = 0.019334 * rgb[0] + 0.119193 * rgb[1] + 0.950227 * rgb[2]; } 因此将SPD转为RGB: 1234567&lt;SampledSpectrum Public Methods&gt; += void ToRGB(flaot rgb[3]) const { float xyz[3]; ToXYZ(xyz); XYZToRGB(xyz,rgb); } 介绍完了如何使用SPD计算RGB，那么如何通过RGB得到SPD? 通过测量得到以下数据 123456789101112131415161718&lt;Spectrual Data Declaration&gt; += static const int nRGB2SpectSamples = 32; extern const float RGB2SpectLambda[nRGB2SpectSamples]; extern const float RGBRefl2SpectWhite[nRGB2SpectSamples]; extern const float RGBRefl2SpectCyan[nRGB2SpectSamples]; extern const float RGBRefl2SpectMagenta[nRGB2SpectSamples]; extern const float RGBRefl2SpectYellow[nRGB2SpectSamples]; extern const float RGBRefl2SpectRed[nRGB2SpectSamples]; extern const float RGBRefl2SpecGreen[nRGB2SpectSamples]; extern const float RGBRefl2SpectBlue[nRGB2SpectSamples]; extern const float RGBIllum2SpectWhite[nRGB2SpectSamples]; extern const float RGBIllum2SpectCyan[nRGB2SpectSamples]; extern const float RGBIllum2SpectMagenta[nRGB2SpectSamples]; extern const float RGBIllum2SpectYellow[nRGB2SpectSamples]; extern const float RGBIllum2SpectRed[nRGB2SpectSamples]; extern const float RGBIllum2SpectGreen[nRGB2SpectSamples]; extern const float RGBIllum2SpectBlue[nRGB2SpectSamples]; 如果RGB颜色用于描述光源的发射光，那么应该使用表示发射源的光谱能量分布的转换表进行计算. RGBillum2Spect*使用的是D65光谱能量分布，为CIE用于表示正午日光的标准. 用于计算方便，可以将RGBRefl2Spect*,RGBillum2Spect*分布，在初始化阶段重采样为SampledSpectrum 12345678910111213141516&lt;SampledSpectrum Private Data&gt; static SampledSpectrum rgbRelf2SpectWhite; static SampledSpectrum rgbRelf2SpectCyan; static SampledSpectrum rgbRelf2SpectMagenta; static SampledSpectrum rgbRelf2SpectYellow; static SampledSpectrum rgbRelf2SpectRed; static SampledSpectrum rgbRelf2SpectGreen; static SampledSpectrum rgbRelf2SpectBlue; static SampledSpectrum rgbIllum2SpectWhite; static SampledSpectrum rgbIllum2SpectCyan; static SampledSpectrum rgbIllum2SpectMagenta; static SampledSpectrum rgbIllum2SpectYellow; static SampledSpectrum rgbIllum2SpectRed; static SampledSpectrum rgbIllum2SpectGreen; static SampledSpectrum rgbIllum2SpectBlue; 1234567891011121314151617181920212223242526272829303132&lt;Compute RGB to spectrum functions for SampledSpectrum&gt; = float wl0 = Lerp(float(i) / float(nSpectralSamples),sampledLambdaStart, sampledLambdaEnd); float wl1 = Lerp(float(i+1) / float(nSpectralSamples),sampledLambdaStart, sampledLambdaEnd); rgbRefl2SpectWhite.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBRefl2SpectWhite, nRGB2SpectSamples, wl0, wl1); rgbRefl2SpectCyan.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBRefl2SpectCyan, nRGB2SpectSamples, wl0, wl1); rgbRefl2SpectMagenta.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBRefl2SpectMagenta, nRGB2SpectSamples, wl0, wl1); rgbRefl2SpectYellow.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBRefl2SpectYellow, nRGB2SpectSamples, wl0, wl1); rgbRefl2SpectRed.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBRefl2SpectRed, nRGB2SpectSamples, wl0, wl1); rgbRefl2SpectGreen.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBRefl2SpectGreen, nRGB2SpectSamples, wl0, wl1); rgbRefl2SpectBlue.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBRefl2SpectBlue, nRGB2SpectSamples, wl0, wl1); rgbIllum2SpectWhite.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBIllum2SpectWhite, nRGB2SpectSamples, wl0, wl1); rgbIllum2SpectCyan.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBIllum2SpectCyan, nRGB2SpectSamples, wl0, wl1); rgbIllum2SpectMagenta.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBIllum2SpectMagenta, nRGB2SpectSamples, wl0, wl1); rgbIllum2SpectYellow.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBIllum2SpectYellow, nRGB2SpectSamples, wl0, wl1); rgbIllum2SpectRed.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBIllum2SpectRed, nRGB2SpectSamples, wl0, wl1); rgbIllum2SpectGreen.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBIllum2SpectGreen, nRGB2SpectSamples, wl0, wl1); rgbIllum2SpectBlue.c[i] = AverageSpectrumSamples(RGB2SpectLambda, RGBIllum2SpectBlue, nRGB2SpectSamples, wl0, wl1); RGB转Spectrum $$if \\quad r &lt; g &lt; b$$ $$(r,g,b) = (r,r,r)+(0,g-r,g-r)+(0,0,b-g)=r(1,1,1)+(g-r)(0,1,1)+(b-g)(0,0,1)$$ $$if \\quad r &lt; b &lt; g$$ $$(r,g,b)=(r,r,r)+(0,b-r,b-r)+(0,g-b,0)=r(1,1,1)+(b-r)(0,1,1)+(g-b)(0,1,0)$$ … (1,1,1):White (0,1,1):Cyan (0,0,1):Blue (0,1,0):Green 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;Spectrum Utility Declaration&gt; += enum SpectrumType {SPECTRUM_REFLECTANCE, SPECTRUM_ILLUMINANT};&lt;Spectrum Method Definitions&gt; += SampledSpectrum SampledSpectrum::FromRGB(const float rgb[3] , SpectrumType type) { SampledSpectrum r; if(type == SPECTRUM_REFLECTANCE) { &lt;Convert reflectance spectrum to RGB&gt; } else { &lt;Convert illuminant spectrum to RGB&gt; } return r.Clamp(); }&lt;Convert reflectance spectrum to RGB&gt; = if(rgb[0] &lt;= rgb[1] &amp;&amp; rgb[0] &lt;= rgb[2]) { &lt;Compute reflectance SampledSpectrum with rgb[0] as minimum&gt; } else if(rgb[1] &lt;= rgb[0] &amp;&amp; rgb[1] &lt;= rgb[2]) { &lt;Compute reflectance SampledSpectrum with rgb[1] as minimum&gt; } else { &lt;Compute reflectance SampledSpectrum with rgb[2] as minimum&gt; }&lt;Compute reflectance SampledSpectrum with rgb[0] as minimum&gt; = r += rgb[0] * rgbRefl2SpectWhite; if(rgb[1] &lt;= rgb[2]) { r += (rgb[1] - rgb[0]) * rgbRefl2SpectCyan; r += (rgb[2] - rgb[1]) * rgbRefl2SpectBlue; } else { r += (rgb[2] - rgb[0]) * rgbRefl2SpectCyan; r += (rgb[1] - rgb[2]) * rgbRefl2SpectGreen; } RGBSpectrumRGBSpectrum使用R,G,B分量的加权和来表示SPDs 123456&lt;Spectrum Declarations&gt; += class RGBSpectrum : public CofficientSpectrum&lt;3&gt; { public: &lt;RGBSpectrum Public Methods&gt; }; FromRGB这个函数就简单了，因此我们存储的就是rgb 12345678910111213141516&lt;RGBSpectrum Public Methods&gt; += static RGBSpectrum FromRGB(const float rgb[3], SpectrumType type = SPECTRUM_REFLECTION) { RGBSpectrum s; s.c[0] = rgb[9]; s.c[1] = rgb[1]; s.c[2] = rgb[2]; return s; }&lt;RGBSpectrum Public Methods&gt; += void TOrgb(float* rgb) const { rgb[0] = c[0]; rgb[1] = c[1]; rgb[2] = c[2]; } 根据SPD计算RGB,通过光谱匹配函数计算XYZ,然后XYZ转为RGB 1234567891011121314151617181920212223242526272829303132333435&lt;RGBSpectrum Public Methods&gt; += static RGBSpectrum FromSampled(const float* lambda, const float* v, int n) { float xyz[3] = {0,0,0}; float yint = 0.0f; for(int i = 0; i &lt; nCIESamples; i++) { yint += CIE_Y[i]; float val = InterpolateSpectrumSamples(lambda, v, n, CIE_lambda[i]); xyz[0] += val * CIE_X[i]; xyz[1] += val * CIE_Y[i]; xyz[2] += val * CIE_Z[i]; } xyz[0] /= yint; xyz[1] /= yint; xyz[2] /= yint; return FromXYZ(xyz); }&lt;Spectrum Method Definitions&gt; += float InterpolateSpectrumSamples(const float* lambda, const float* vals, int n, float l) { if(l &lt;= lambda[0]) return vals[0]; if(l &gt;= lambda[n-1]) return vals[n-1]; for(int i=0; i &lt; n-1; i++) { if(l &gt;= lambda[i] &amp;&amp; l &lt;= lambda[i+1]) { float t = (l - lambda[i]) / (lambda[i+1] - lambda[i]); return Lerp(t , vals[i] , vals[i+1]); } } } LinearSpace RGB to sRGB$$\\begin{equation}C_{srgb}=\\begin{cases}12.92C_{linear} &amp; C_{linear} \\leq 0.0031308 \\notag\\\\[2ex](1+\\alpha)C_{linear}^{\\frac{1}{2.4}} - \\alpha &amp; C_{linear} &gt; 0.0031308\\end{cases} \\end{equation}$$ Reference sRGB PBRT","link":"/Color-And-Radiometry/"},{"title":"D3D Event Query","text":"使用方法事件查询步骤: pDeviceContext-&gt;Begin(pQuery) pDeviceContext-&gt;End(pQuery) pDeviceContext-&gt;GetData(pQuery , &amp;queryData , sizeof(UINT64) , 0) 注意事项Begin()并非是必须的,但是End()是必须的 End()调用之后，必须在GetData()成功之后才能继续调用End(),否则将会报D3D Warning 常见用法1234567891011121314D3D11_QUERY_DESC queryDesc;... // Fill out queryDesc structureID3D11Query * pQuery;pDevice-&gt;CreateQuery(&amp;queryDesc, &amp;pQuery);pDeviceContext-&gt;Begin(pQuery);... // Issue graphics commandspDeviceContext-&gt;End(pQuery);UINT64 queryData; // This data type is different depending on the query typewhile( S_OK != pDeviceContext-&gt;GetData(pQuery, &amp;queryData, sizeof(UINT64), 0) ){} 实际需求公司残影实现是通过记录下角色的多帧的动画数据(蒙皮矩阵),然后将这些蒙皮数据写到Palette上,然后在VS阶段用于蒙皮计算 现在我将所有的蒙皮计算单独挪到一个阶段 因此，残影的渲染需要先走一遍CS蒙皮,将蒙皮结果(Model空间)写到一个Buffer中,再将该Buffer作为渲染的输入流 123456pDeviceContext-&gt;CSSetUnorderedAccessView(iStartSlot , 1 , &amp;pGhostBuffer , nullptr);RunComputeSkin(...);...pDeviceContext-&gt;IASetVertexBuffer(iStartSlot , 1 , &amp;pGhostBuffer , sizeof(VertexFormat), iGhostOffset);Render(...);... 由于残影的存在时间很短,存在大量的创建与销毁,因此每个残影一个Buffer的话,将导致资源的重复创建与销毁 所以,我决定使用一个大的Buffer让所有的残影共享这段Buffer,并且可以通过限制残影的个数 1234567ID3D11Buffer* pGhostBuffer = nullptr;// Create Buffer , Bind As VertexBuffer &amp; UAV// VertexBuffer can&apos;t create as StructuredBuffer// so MiscFlag set to D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS// Usage: D3D11_USAGE_DEFAULT,just GPU read and write// StructuredByteStride = sizeof(VertexFormat) * iVertexNum / 4// D3D11_RESOURCE_MISC_BUFFER_ALLOW_RAW_VIEWS must DWORD Align 既然多个残影共享同一段Buffer,那么就可能出现即写又读的情况，造成GPU与GPU之间的同步等待,这个消耗非常巨大 因此,对于每个残影,都记录一个偏移以及数量,用于表示占用Buffer中的哪一段 12345678910111213141516struct GhostSubBuffer{ int offset; int num; bool GPUUsed; ...};static vector&lt;GhostSubBuffer&gt; subBuffers;class VFX_CloneEntity{ ...public: std::map&lt;VDynamicMesh,int&gt; buffers; // 角色每个Part引用的GhostSubBuffer索引} 每个残影创建之后,第一次运行CS时,尝试从Buffer中分配一段可用的区间,若分配失败,则该残影不渲,下一帧再继续检测 若分配成功,则走一次蒙皮,将数据缓存在Buffer中，之后渲染不需要再重复计算 1234567891011121314int bufferOffset = skincache_ghost_get_buffer(cloneEntity , pPartMesh);&lt;Query Ghost Buffer GPU State&gt;if(bufferOffset == -1){ bufferOffset = skincache_ghost_map_buffer(cloneEntity , pPartMesh); if(bufferOffset == -1) continue; skincache_ghost_compute_skinning(..);}&lt;Query End&gt; 那么必然会涉及到一个何止回收这一段区间的问题,区间被回收之后,就意味着这段区间可被再次使用 因此,我们需要保证回收时这段区间已不再被GPU使用,从而避免同一段Buffer既作为SRV,又作为CS的输出UAV的情况 因为,可以为每一段分配的Buffer区间创建一个ID3D11Query* query,在渲染命令之后调用pDeviceContext-&gt;End(pQuery) 12345struct GhostSubBuffer{ ... ID3D11Query* query = nullptr;} 然后每帧进行查询,若该残影已被销毁且GPU不再使用这段Buffer,则将其回收 因为我们查询GPU是否在使用这段Buffer并不希望一直等待,因此,可能要在多帧之后GetData()才能返回TRUE. 但在GetData()返回TRUE之前不能多次调用End(),因此需要记录下相应的状态 123456789101112131415&lt;Query Ghost Buffer GPU State&gt; = GhostSubBuffer&amp; sb = subBuffers[i]; if(sb.GPUUsed &amp;&amp; pDeviceContext-&gt;GetData(sb.query, &amp;queryData, sizeof(UINT64), 0) == S_OK) { sb.GPUUsed = false; } RecycleBuffer();&lt;Query End&gt; GhostSubBuffer sb; if(!sb.GPUUsed &amp;&amp; sb.query) { sb.GPUUsed = true; } ID3D11Query可以将其放到一个池中,以便重复利用","link":"/D3D-Event-Query/"},{"title":"debug tool for game develop","text":"本文将介绍各类开发调试工具的主要用途以及使用方式 CPUSimplePefPerfDogPerfettoVTuneSuperluminalUnreal Insights启动命令行中添加如下参数： 1-tracehost=主机ip -trace=default,cpu,memory,gpu -statnamedevent 启动UnrealInsights后再启动进程，则会自动开始捕获性能数据 Android可修改UE4CommandLine.txt或通过adb shell setprop debug.ue.commandline \\&quot;启动参数\\&quot;设置 框选范围后可在右侧Counter界面查看该段时间内的Counter数，用于统计一段时间内的平均开销 在日志窗口中点击某条日志后时间轴会定位到对应帧： Android Studio ProfilerWPA &amp; WPRWPR可以用于生成ETL文件，WPA用于查看ETL格式文件，ETL全称为Event Trace Log 还可以通过XPerf基于命令行形式生成ETL，以及UIForETW生成ETL文件 其记录大量的事件信息，可以查看CPU利用率，GPU利用率，文件读写，磁盘读写，各进程/线程的调用堆栈等 比如我们可以使用该文件分析卡顿： 查看CPU Usage视图，找到大致发生卡顿的时间区域中CPU利用率下降的区域 右键Zoom后，将会放大指定的框选区域，展开指定进程的堆栈，会按开销占比显示这段时间内的堆栈 使用CPU Usage (Attributed)可以查看各线程的CPU占比开销，比如主线程发生卡顿时渲染线程的利用率会下降 以此便可查看此时主线程在执行什么堆栈 如果发现文件读写卡住，则可以打开File IO视图查看 GPUView该工具目前包含在Windows Performance Toolkit(WPT)中，虽然工具名为GPUView，但也可以用于分析CPU卡顿 GPUView可以选中区域并放大查看这段区域的CPU采样堆栈以及各进程的CPU Queue 以及CPU Queue上的任务在GPU Queue上的执行顺序，通过Event List可以查看各类事件的触发时间 我们可以通过ID3DUserDefinedMarker添加D3D PerfMark，用于标记渲染Pass，可参考：GPUView EventView 以及使用GUID注册任意事件调用：how to add a custom event which is visible in gpuview PerfSDKXCode InstrumentsXCode LLDBLLDB设置内存断点: 1watchpoint set expression -- 地址 查看寄存器内容，例如查看r0寄存器： 1register read r0 具体使用可以问ChatGPT GPURenderdocRenderdoc在Windows上采用DirectX模拟的方式Replay其它图形API，Android的Hook分为Layer与非Layer的形式 DirectX程序需使用D3D_DEBUG创建Device才能截帧，Android需启用debuggable 当前存在的问题 贴图Preview Mobile上的ASTC贴图无法正确显示，比如UE中某张贴图格式指定为BGRA，在Mobile上会被压缩为ASTC 由于PC上是以DX进行模拟，因此只能以RGBA进行显示，因此Renderdoc Preview会出现错误 运算精度 比如RGBA16F的贴图，由于IEEE 16Bit Float的有效精度为11位，最多显示2048。 当计算结果超出2048时，显示结果将会出现错误。 NSightNSight有多个产品，这里主要介绍两个： NSight Graphics NSight System NSight Graphics最常用的FrameDebugger，用于截取一帧：支持D3D11, D3D12, OpenGL, Vulkan 以及提供了GPU Trace Profiler，用于Trace多帧的GPU执行状态，但是不支持D3D11，最好使用管理员权限启动 Trace显示如下： Ctrl+滚轮可以放大指定区域，查看各Pass执行开销： 以及提供了Trace Analysis, Trace Compare功能方便进行性能分析，唯一的不足在于无法长时间Trace NSight System可以直接启动NSight System，也可以通过NSight Graphics的System Trace页启动，要求应用使用D3D12/Vulkan 然后配置Trace选项，下图为启动后自动开始Trace 实测该工具经常分析失败，数据多时失败概率显著增加 Snapdragon Profiler 查看带宽：GMEM Load/Store Mali Offline CompilerAdreno Offline CompilerArm Graphics ToolAdreno GPU ProfilerAndroid GPU InspectorPVRTuneRadeon GPU ProfilerXCode Instruments Optimizing GPU performance GPUView基本用法参考1.9节 PIX微软官方出品，可以实现Timeline Trace，这点优于NSight Graphics MemoryAdroid Address SanitizerHWAddress SanitizerLoli ProfilerUnreal Memory Report游戏内的Console输入memreport -full即会在Saved/Profiling下生成报告 Unreal LowLevelMemory可使用PerfreportTool可视化CSV: StompMalloc该模式利用缺页机制实现检测，由于PC暂不支持Address Sanitizer，该方案依然可考虑使用 Unreal Memory InsightsADB1adb shell dumpsys memoryinfo UE高级性能剖析技术 – Android内存分布和优化 XCode Address Sanitizer Zombie Object Malloc History Memory Graph DecompileIDAAndroid真机调试包体要求： debuggable为true: UE打包时ForDistribution设置为False即可 启动Android_ServerADB连接手机后打开Android Studio，随便新建或打开一个项目，找到Device File Explorer 找到目标应用，如:/data/data/com.lilithgames.xgame.gp,在其上右键， 选择Upload 在打开的文件选择框中选择android_server64(32位的选android_server)，该文件位于： IDAPro安装目录/dbgsrv/android_server64 成功将android_server64上传至手机后，在cmd窗口执行: 进入shell环境：adb shell 执行run-as: run-as com.lilithgames.xgame.gp 提权： chmod 777 android_server64 启动server: 1234567# android10及以上使用该命令IDA_LIBC_PATH=/apex/com.android.runtime/lib64/bionic/libc.so ./android_server64# android10以下使用该命令./android_server64adb shell am start -D -n com.lilithgames.xgame.gp/com.epicgames.ue4.SplashActivity 此时cmd窗口可见到监听23946端口的提示，接下来再开一个cmd窗口用于转发端口： 1adb forward tcp:23946 tcp:23946 Attach Debug设置调试器：这里是用Remote ARM Linux/Android debugger 打开Process Option,设置调试信息： 接下来选择Attach To Process并选择目标进程进行挂载： 其它命令: 查询端口占用：adb shell netstat -tulpn 提权：adb shell chmod 777 /data/local/android_server64 读取so BuildID: readelf -n xxx.so x64dbg","link":"/Debug-Tools/"},{"title":"Disney BRDF","text":"Disney Diffuse BRDF该模型为经验模型,目的是根据材质的roughness表现的不同,平滑的表面更暗一些,粗糙的表面亮一些:$$f_d = \\frac{baseColor}{\\pi}(1 + (F_{D90} - 1)(1 - cos\\theta_l)^5)(1 + (F_{D90} - 1)(1 - cos\\theta_v)^5)$$ $$F_{D90} = 0.5 + 2\\times roughness \\times cos^2\\theta_d$$ 12345678float3 diffuse(float roughness, float LdotH, float NdotL, float NdotV, float3 BaseColor){ float FresnelDiffuse = 0.5 + 2 * sqr(LdotH) * roughness; float fresnelL = 1 + (fresnelDiffuse - 1) * pow(1 - NdotL, 5); float fresnelV = 1 + (fresnelDiffuse - 1) * pow(1 - NdotV, 5); float3 Fd = (BaseColor / PI) * fresnelL * fresnelV; return Fd;}","link":"/Disney-BRDF/"},{"title":"FFT Ocean Implement","text":"理论根据Phillips spectrum生成波谱$$P_h(\\vec{k}) = A\\frac{exp(\\frac{-1}{kL})^2}{k^4} |\\vec{k}\\cdot \\vec{\\omega}|^2\\tag{1}$$$$L = \\frac{V^2}{g}$$ V: 风速 g: 重力常量 $\\vec{\\omega}$: 风向 A: 数值常量 公式中$|\\vec{k}\\cdot \\vec{\\omega}|^2$项用于抵消与风向垂直的波 该模型相对简单,但在高波数$|k|$的情况下收敛性比较差,一个简单的解决方案是乘上一个因子:$$exp(-k^2\\ell^2)$$$\\ell$为波长,且$\\ell \\ll L$,用于抑制波长小于$\\ell$的波 计算频域波形振幅$$\\tilde{h}_0(\\vec{k}) = \\frac{1}{\\sqrt{2}}(\\xi_r + i\\xi_i)\\sqrt{P_h(\\vec{k})}\\tag{2}$$ $\\xi_r$,$\\xi_i$为独立无关的高斯随机数,且分布满足期望为0,标准差为1 根据色散关系,计算时间t处的频域振幅$$色散关系:\\quad \\omega(k) = \\sqrt{gk}\\tag{3}$$$$\\tilde{h}(\\vec{k},t) = \\tilde{h}_0(k)exp(i\\omega(k)t) + \\tilde{h}_0^*(-\\vec{k})exp(-i\\omega(k)t)\\tag{4}$$ $\\tilde{h}_0(-\\vec{k})^*$:与$\\tilde{h}_0(-\\vec{k})$共轭,注意不是$\\tilde{h}_0(\\vec{k})$ 该形式满足:$\\tilde{h}^*(\\vec{k},t) = \\tilde{h}(-\\vec{k},t)$ 使用IFFT变换到时域$$h(\\vec{x},t) = \\sum_{\\vec{k}} \\tilde{h}(\\vec{k},t)exp(i\\vec{k}\\cdot \\vec{x}) \\tag{5}$$ $$\\vec{k} = (k_x,k_z),\\quad k_x = \\frac{2\\pi n}{L_x},\\quad k_z = \\frac{2\\pi m}{L_z}$$ $$\\frac{-N}{2} \\leq n &lt; \\frac{N}{2},\\quad \\frac{-M}{2} \\leq m &lt; \\frac{M}{2}$$ FFT处理在离散点$\\vec{x} = (\\frac{n L_x}{N}, \\frac{m L_z}{M})$处生成高度域 因为波浪在越靠近波尖处越密集,因此可以通过以下公式计算水平偏移:$$D(\\vec{x},t) = \\sum_{\\vec{k}} -i\\frac{\\vec{k}}{k}\\tilde{h}(\\vec{k},t)exp(i\\vec{k}\\cdot \\vec{x})\\tag{6}$$ 令:$$D(\\vec{k},t) = -i\\frac{\\vec{k}}{k}\\tilde{h}(\\vec{k},t) = D(x,t) + iD(z,t)\\tag{7}$$ $$\\Rightarrow D(x,t) = -i k_x \\tilde{h}(\\vec{k},t)\\tag{8}$$$$\\Rightarrow D(z,t) = -k_z \\tilde{h}(\\vec{k},t)\\tag{9}$$$$\\Rightarrow D(\\vec{x},t) = \\sum_{\\vec{k}} D(\\vec{k},t)exp(i\\vec{k}\\cdot \\vec{x})\\tag{10} = \\sum_{\\vec{k}} D(x,t)exp(i\\vec{k}\\cdot \\vec{x}) + i\\sum_{\\vec{k}} D(z,t)exp(i\\vec{k}\\cdot \\vec{x})$$ 此时网格点的真正的位置为:$\\vec{x} + \\lambda D(\\vec{x},t)$ 可见式(5)与式(10)都是IFFT变换形式 接下来将式(5)进行分解: $$h(\\vec{x},t) = \\sum_{\\vec{k}} \\tilde{h}(\\vec{k},t)exp(i\\vec{k}\\cdot \\vec{x})$$$$\\Rightarrow h(x,z,t) = \\sum_{n=-\\frac{N}{2}}^{\\frac{N}{2} - 1} \\sum_{m=-\\frac{M}{2}}^{\\frac{M}{2} - 1} \\tilde{h}(n,m,t)exp(i(\\frac{2\\pi n}{L_x},\\frac{2\\pi m}{L_z}) \\cdot (x,z))$$$$\\Rightarrow h(x,z,t) = \\sum_{n=-\\frac{N}{2}}^{\\frac{N}{2} - 1} \\sum_{m=-\\frac{M}{2}}^{\\frac{M}{2} - 1} \\tilde{h}(n,m,t)exp(i\\frac{2\\pi nx}{L_x})exp(i\\frac{2\\pi mz}{L_z})$$$$\\Rightarrow h(x,z,t) = \\sum_{n=0}^{N-1} \\sum_{m=0}^{M -1} \\tilde{h}(n-\\frac{N}{2},m-\\frac{M}{2},t)exp(i\\frac{2\\pi (n - \\frac{N}{2})x}{L_x})exp(i\\frac{2\\pi (m - \\frac{M}{2})z}{L_z})$$$$\\Rightarrow h(x,z,t) = \\sum_{n=0}^{N-1} \\sum_{m=0}^{M -1} \\tilde{h}(n-\\frac{N}{2},m-\\frac{M}{2},t)exp(i\\frac{2\\pi nx}{L_x})exp(-i\\frac{\\pi Nx}{L_x})exp(i\\frac{2\\pi mz}{L_z})exp(-i\\frac{\\pi M z}{L_z})$$$$\\Rightarrow h(x,z,t) = exp(-i\\frac{\\pi Nx}{L_x}) exp(-i\\frac{\\pi M z}{L_z}) \\sum_{n=0}^{N-1} \\sum_{m=0}^{M -1} \\tilde{h}(n-\\frac{N}{2},m-\\frac{M}{2},t)exp(i\\frac{2\\pi nx}{L_x})exp(i\\frac{2\\pi mz}{L_z})$$ 令:$$h’(x,z,t) = \\sum_{n=0}^{N-1} \\sum_{m=0}^{M -1} \\tilde{h}(n-\\frac{N}{2},m-\\frac{M}{2},t)exp(i\\frac{2\\pi nx}{L_x})exp(i\\frac{2\\pi mz}{L_z})$$ $$\\Rightarrow h(x,z,t) = exp(-i\\frac{\\pi Nx}{L_x}) exp(-i\\frac{\\pi M z}{L_z}) h’(x,z,t)$$ 当$N = L_x, M= L_z$时:$$\\Rightarrow h(x,z,t) = exp(-i\\pi x) exp(-i\\pi z) h’(x,z,t)$$ $$\\because e^{ix} = cos x + i sin x$$ $$\\therefore h(x,z,t) = (-1)^{x+z}h’(x,z,t)$$ $h’(x,z,t)$为二维FFT,即逐行做一维IFFT再逐列做一维IFFT,FFT计算可参考库利-图基快速傅立叶变换算法 生成DisplacementMap在计算完h&apos;(x,z,t)后还需要乘上$(-1)^{x+z}$才是$h(x,z,t)$,我们可以将$h(x,z,t)$以及$D(\\vec{x},t)$存到贴图中称之为DisplacementMap 法线计算法线通过有限差分即可,$h(\\vec{x},t)$存在DisplacementMap中 设网格实际大小为$(L_x,L_z)$,DisplacementMap分辨率为(N,M),则在(x,z)处:$$T_x = (\\frac{2L_x}{N}, h(x + 1, z, t) - h(x - 1, z, t), 0)$$$$T_z = (0, h(x, z + 1, t) - h(x, z - 1, t), \\frac{2L_z}{M})$$ $$\\begin{align}Normal &amp;= T_z \\times T_x \\notag\\\\ &amp;= \\begin{bmatrix} i &amp; j &amp; k \\\\ 0 &amp; h(x, z + 1, t) - h(x, z - 1, t) &amp; \\frac{2L_z}{M} \\\\ \\frac{2L_x}{N} &amp; h(x + 1, z, t) - h(x - 1, z, t) &amp; 0 \\end{bmatrix} \\notag\\\\ &amp;= (\\frac{-2L_z(h(x + 1, z, t) - h(x - 1, z, t))}{M}, \\frac{4L_x L_z}{NM}, \\frac{-2L_x (h(x, z + 1, t) - h(x, z - 1, t))}{N})\\notag\\end{align}$$ 实现Phillips123456789101112131415float Phillips(Vector2 K, Vector2 windDir, float windSpeed, float amplitude, float dir_depend){ float L = windSpeed * windSpeed / GRAV_ACCEL; float l = L / 1000; float Ksqr = K.x * K.x + K.y * K.y; float Kcos = K.x * windDir.x + K.y * windDir.y; float phillips = amplitude * Mathf.Exp(-1.0f / (Ksqr * L * L)) / (Ksqr * Ksqr * Ksqr) * (Kcos * Kcos); // 与风向大于90度的波,减弱 if (Kcos &lt; 0.0f) phillips *= dir_depend; return phillips * Mathf.Exp(-Ksqr * l * l);} 计算$\\tilde{h}_0(\\vec{k})$1234567891011121314151617181920212223242526272829303132333435float Gauss(){ float u1 = Random.Range(0.0f, 1.0f); float u2 = Random.Range(0.0f, 1.0f); if (u1 &lt; 1e-6f) u1 = 1e-6f; return Mathf.Sqrt(-2 * Mathf.Log(u1)) * Mathf.Cos(2 * Mathf.PI * u2);}void ComputeH0(OceanParameter parameter, ref Vector2[] h0, ref float[] omega){ Vector2 windDir = parameter.wind_dir.normalized; Vector2 K = Vector2.zero; for(int i = 0; i &lt; parameter.displaceMap_dimension; i++) { K.y = (-parameter.displaceMap_dimension / 2.0f + i) * (2 * Mathf.PI / parameter.patch_size); for(int j = 0; j &lt; parameter.displaceMap_dimension; j++) { K.x = (-parameter.displaceMap_dimension / 2.0f + j) * (2 * Mathf.PI / parameter.patch_size); float phillips = (K.x == 0 &amp;&amp; K.y == 0) ? 0 : Mathf.Sqrt(Phillips(K, windDir, parameter.wind_speed, parameter.wave_amplitude * 1e-7f, parameter.wind_dependency)); int index = i * parameter.displaceMap_dimension + j; float Gauss_x = Gauss() , Gauss_y = Gauss(); h0[index].x = phillips * Gauss_x * HALF_SQRT_2; h0[index].y = phillips * Gauss_y * HALF_SQRT_2; omega[index] = Mathf.Sqrt(GRAV_ACCEL * Mathf.Sqrt(K.x * K.x + K.y * K.y)); } }} 计算$h(\\vec{k},t),D(x,t),D(z,t)$与时间相关,需要每帧计算,这里将其放到ComputeShader中去算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#pragma kernel UpdateSpecturmCS#define BLOCK_SIZE 16#define BLOCK_SIZE 16StructuredBuffer&lt;float2&gt; H0;StructuredBuffer&lt;float&gt; Omega;RWStructuredBuffer&lt;float2&gt; HK;RWStructuredBuffer&lt;float2&gt; Dx;RWStructuredBuffer&lt;float2&gt; Dy;uint Dimension;float curTime;[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]void UpdateSpecturmCS(uint3 id : SV_DispatchThreadID){ uint in_Index = id.y * Dimension + id.x; // 共轭 uint in_mIndex = (Dimension - id.y) * Dimension + (Dimension - id.x); uint out_index = id.y * Dimension + id.x; // H(0) -&gt; H(k) float2 H0_k = H0[in_Index]; float2 H0_mk = H0[in_mIndex]; float _sin = sin(Omega[in_Index] * curTime); float _cos = cos(Omega[in_Index] * curTime); float2 ht; ht.x = (H0_k.x + H0_mk.x) * _cos - (H0_k.y + H0_mk.y) * _sin; ht.y = (H0_k.x - H0_mk.x) * _sin + (H0_k.y + H0_mk.y) * _cos; // Dx,Dy float kx = id.x - Dimension * 0.5f; float ky = id.y - Dimension * 0.5f; float sqr_k = kx * kx + ky * ky; float rsqr_k = 0; if (sqr_k &gt; 1e-12f) rsqr_k = 1.0f / sqrt(sqr_k); kx *= rsqr_k; ky *= rsqr_k; float2 dt_x = float2(ht.y * kx, -ht.x * kx); float2 dt_y = float2(ht.y * ky, -ht.x * ky); if(id.x &lt; Dimension &amp;&amp; id.y &lt; Dimension) { HK[out_index] = ht; Dx[out_index] = dt_x; Dy[out_index] = dt_y; }} Radix-2 IFFT GPU1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#pragma kernel Radix2CS#pragma kernel transpose#pragma kernel copyBuffer#pragma kernel RowBitReverse#define THREAD_NUM 128#define PI 3.14159274uint thread_count;uint istride;uint bit_count;uint N;StructuredBuffer&lt;int&gt; bit_reverse;StructuredBuffer&lt;float2&gt; input;RWStructuredBuffer&lt;float2&gt; output;int bitReserve(uint src, uint bit_num){ int dst = 0; for (uint i = 0; i &lt; bit_num; i++) { dst = (dst &lt;&lt; 1) + (src &amp; 1); src = src &gt;&gt; 1; } return dst;}[numthreads(THREAD_NUM, 1, 1)]void Radix2CS(uint3 thread_id : SV_DispatchThreadID){ if (thread_id.x &gt;= thread_count) return; uint mod = thread_id.x &amp; (istride - 1); uint addr = ((thread_id.x - mod) &lt;&lt; 1) + mod; float2 t = input[addr]; float2 u = input[addr + istride]; uint w = (addr - mod) / (istride &lt;&lt; 1); w = bitReserve(w, bit_count); float buttfly_cos = cos(2 * PI * w / (2 &lt;&lt; bit_count)); float buttfly_sin = sin(2 * PI * w / (2 &lt;&lt; bit_count)); output[addr] = float2(t.x + u.x * buttfly_cos - u.y * buttfly_sin, t.y + u.x * buttfly_sin + u.y * buttfly_cos); output[addr + istride] = float2(t.x - u.x * buttfly_cos + u.y * buttfly_sin, t.y - u.x * buttfly_sin - u.y * buttfly_cos);}[numthreads(THREAD_NUM, 1, 1)]void transpose(uint3 thread_id : SV_DispatchThreadID){ if(thread_id.x &gt;= thread_count) return; int row = thread_id.x / N; int col = thread_id.x &amp; (N - 1); output[col * N + row] = input[thread_id.x]; row = (thread_id.x + istride) / N; col = (thread_id.x + istride) &amp; (N - 1); output[col * N + row] = input[thread_id.x + istride];}[numthreads(THREAD_NUM,1,1)]void copyBuffer(uint3 thread_id : SV_DispatchThreadID){ if(thread_id.x &gt;= thread_count) return; output[thread_id.x] = input[thread_id.x]; output[thread_id.x + istride] = input[thread_id.x + istride];}[numthreads(THREAD_NUM,1,1)]void RowBitReverse(uint3 thread_id : SV_DispatchThreadID){ if (thread_id.x &gt;= thread_count) return; int row = thread_id.x / N; int col = thread_id.x &amp; (N - 1); output[bit_reverse[row] * N + col] = input[thread_id.x]; row = (thread_id.x + istride) / N; col = (thread_id.x + istride) &amp; (N - 1); output[bit_reverse[row] * N + col] = input[thread_id.x + istride];} Radix2CS用于计算Radix-2 IFFT,transpose用于实现行列转置,RowBitReverse实现逐行比特反转排列 以下Radix-2 FFT计算过程,先逐列IFFT,位反转,逐行IFFT(转置,逐列IFFT,位反转,转置) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public void EvaluteFFT(ComputeBuffer srcBuffer, ref ComputeBuffer dstBuffer){ if (mTempBuffer == null || mBitReverseBuffer == null || dstBuffer == null || mRadix2FFT == null) return; ComputeBuffer[] swapBuffer = new ComputeBuffer[2]; swapBuffer[0] = dstBuffer; swapBuffer[1] = mTempBuffer; int interation = (int)(Mathf.Log(mSize) / Mathf.Log(2)); int thread_count = mSize * mSize / 2; int thread_group = thread_count / OceanConst.RADIX2FFT_THREAD_NUM; for (int i = 0; i &lt; interation; i++) { mRadix2FFT.SetInt(&quot;thread_count&quot;, thread_count); mRadix2FFT.SetInt(&quot;istride&quot;, thread_count / (1 &lt;&lt; i)); mRadix2FFT.SetInt(&quot;bit_count&quot;, i); mRadix2FFT.SetInt(&quot;N&quot;, mSize); mRadix2FFT.SetBuffer(0, &quot;input&quot;, i == 0 ? srcBuffer : swapBuffer[0]); mRadix2FFT.SetBuffer(0, &quot;output&quot;, swapBuffer[1]); mRadix2FFT.Dispatch(0, thread_group, 1, 1); SwapBuffer(ref swapBuffer[0], ref swapBuffer[1]); } // bit reverse { mRadix2FFT.SetInt(&quot;thread_count&quot;, thread_count); mRadix2FFT.SetInt(&quot;istride&quot;, thread_count); mRadix2FFT.SetInt(&quot;N&quot;, mSize); mRadix2FFT.SetBuffer(3, &quot;bit_reverse&quot;, mBitReverseBuffer); mRadix2FFT.SetBuffer(3, &quot;input&quot;, swapBuffer[0]); mRadix2FFT.SetBuffer(3, &quot;output&quot;, swapBuffer[1]); mRadix2FFT.Dispatch(3, thread_group, 1, 1); SwapBuffer(ref swapBuffer[0], ref swapBuffer[1]); } // transpose { mRadix2FFT.SetInt(&quot;thread_count&quot;, thread_count); mRadix2FFT.SetInt(&quot;N&quot;, mSize); mRadix2FFT.SetBuffer(1, &quot;input&quot;, swapBuffer[0]); mRadix2FFT.SetBuffer(1, &quot;output&quot;, swapBuffer[1]); mRadix2FFT.Dispatch(1, thread_group, 1, 1); SwapBuffer(ref swapBuffer[0], ref swapBuffer[1]); } for (int i = 0; i &lt; interation; i++) { mRadix2FFT.SetInt(&quot;thread_count&quot;, thread_count); mRadix2FFT.SetInt(&quot;istride&quot;, thread_count / (1 &lt;&lt; i)); mRadix2FFT.SetInt(&quot;bit_count&quot;, i); mRadix2FFT.SetInt(&quot;N&quot;, mSize); mRadix2FFT.SetBuffer(0, &quot;input&quot;, swapBuffer[0]); mRadix2FFT.SetBuffer(0, &quot;output&quot;, swapBuffer[1]); mRadix2FFT.Dispatch(0, thread_group, 1, 1); SwapBuffer(ref swapBuffer[0], ref swapBuffer[1]); } // bit reverse { mRadix2FFT.SetInt(&quot;thread_count&quot;, thread_count); mRadix2FFT.SetInt(&quot;istride&quot;, thread_count); mRadix2FFT.SetInt(&quot;N&quot;, mSize); mRadix2FFT.SetBuffer(3, &quot;bit_reverse&quot;, mBitReverseBuffer); mRadix2FFT.SetBuffer(3, &quot;input&quot;, swapBuffer[0]); mRadix2FFT.SetBuffer(3, &quot;output&quot;, swapBuffer[1]); mRadix2FFT.Dispatch(3, thread_group, 1, 1); SwapBuffer(ref swapBuffer[0], ref swapBuffer[1]); } // transpose { mRadix2FFT.SetInt(&quot;thread_count&quot;, thread_count); mRadix2FFT.SetInt(&quot;N&quot;, mSize); mRadix2FFT.SetBuffer(1, &quot;input&quot;, swapBuffer[0]); mRadix2FFT.SetBuffer(1, &quot;output&quot;, swapBuffer[1]); mRadix2FFT.Dispatch(1, thread_group, 1, 1); SwapBuffer(ref swapBuffer[0], ref swapBuffer[1]); } if (dstBuffer != swapBuffer[0]) { mRadix2FFT.SetInt(&quot;thread_count&quot;, thread_count); mRadix2FFT.SetInt(&quot;istride&quot;, thread_count); mRadix2FFT.SetBuffer(2, &quot;input&quot;, swapBuffer[0]); mRadix2FFT.SetBuffer(2, &quot;output&quot;, dstBuffer); mRadix2FFT.Dispatch(2, thread_group, 1, 1); }} 效果 代码下载 引用 Simulating Ocean Water Ocean Simulation Part One Ocean Simulation Part Two 色散关系 库利-图基快速傅立叶变换算法 Nvidia DirectX 11 Sample","link":"/FFT-Ocean-Implement/"},{"title":"","text":"HISM解析与优化HISM生成HISM原理HISM全名为Hierarchical Instanced Static Mesh，通过按LOD组织为树形结构，每个节点为一个Cluster，每个Cluster由一或多个Mesh组成 每个Cluster的包围盒都为其下所有StaticMesh的包围盒之和，判断可见性时逐级判断即可加速搜索。类结构如下： FStaticMeshInstanceData：存储CPU端实例化数据 FStaticMeshInstanceBuffer: 使用CPU实例化数据构建InstanceBuffer与SRV 渲染流程分为顶点流与ManualVerexFetch两种： 顶点流：通过绑定InstanceBuffer的方式，在Shader端直接取到当前Instance数据 ManualVertexFetch: 通过绑定SRV的方式，使用InstanceId存取数据 HISM与ISM使用相同的VertexFactory，该VertexFactory负责绑定顶点流与SRV以及实例化参数 弊端： 基于Cluster作为Drawcall单元，当Cluster内部部分物体被遮挡时，Instance的连续性将被打断而必须拆分Drawcall HISM构建Landscape GrassHISM重布局为了解决Cluster中部分StaticMesh被遮挡而导致Instance数据在InstanceBuffer不连续，而被迫使用多个Drawcall的情况。我们有以下两种方式： 重排InstanceBuffer 增加一个索引Buffer，使用该Buffer重映射InstanceId 因此我们将类图修改为如下形式: 优缺点 优点：减少Drawcall且通常都会命中缓存 缺点：额外的内存占用，创建Uniformbuffer会给RHI线程带来不小开销 RefUHierarchicalInstancedStaticMesh(HISM)原理分析","link":"/HISM原理与优化/"},{"title":"IBL","text":"Reflectance equation这里采用的反射模型如下:$$L_o(p,\\omega_o) = \\int_\\Omega (k_d \\frac{c}{\\pi} + k_s \\frac{DFG}{4(\\omega_o \\cdot n)(\\omega_i \\cdot n)})L_i(p,\\omega_i)(n \\cdot \\omega_i) d\\omega_i$$ $$\\Rightarrow L_o(p,\\omega_i) = \\int_\\Omega k_d \\frac{c}{\\pi}L_i(p,\\omega_i)n\\cdot \\omega_i d\\omega_i + \\int_\\Omega k_s \\frac{DFG}{4(\\omega_i \\cdot n)(\\omega_o \\cdot n)}L_i(p,\\omega_i)(n \\cdot \\omega_i) d\\omega_i$$ Diffuse Irradiance接下来先看diffuse项:$$L_o = \\int_\\Omega k_d\\frac{c}{\\pi}L_i(p,\\omega_i) (n \\cdot \\omega_i ) d\\omega_i$$$$\\Rightarrow L_o = k_d\\frac{c}{\\pi}\\int_\\Omega L_i(p,\\omega_i) (n\\cdot \\omega_i) d\\omega_i$$$$\\Rightarrow L_o = k_d \\frac{c}{\\pi}\\int_{\\phi = 0}^{2\\pi} \\int_{\\theta = 0}^{\\frac{\\pi}{2}}L_i(p,\\phi_i,\\theta_i)\\cos(\\theta)\\sin(\\theta)d\\phi d\\theta \\tag{1}$$ 蒙特卡洛方法$$\\because E[\\frac{f(x)}{p(x)}] = \\int f(x)dx$$ 设$\\frac{f(x_1)}{p(x_1)},\\frac{f(x_2)}{p(x_2)},…,\\frac{f(x_n)}{p(x_n)}$为独立同分布的随机变量,因此构造估计量如下:$$\\sigma = \\frac{1}{N}\\sum_{i=0}^{N} \\frac{f(x_i)}{p(x_i)}$$根据大数定律得知,样本均值将会收敛于期望值,因此当N增大,估计量将会逐渐逼近于期望$\\int f(x)dx$ 接下来证明下无偏性:$$E[\\sigma] = E[\\frac{1}{N}\\sum_{i=0}^{N} \\frac{f(x_i)}{p(x_i)}]$$$$\\Rightarrow E[\\sigma] = \\frac{1}{N}E[\\sum_{i = 0}^{N}\\frac{f(x_i)}{p(x_i)}]$$$$\\Rightarrow E[\\sigma] = \\frac{1}{N}\\sum_{i = 0}^{N}E[\\frac{f(x_i)}{p(x_i)}]$$$$\\Rightarrow E[\\sigma] = \\frac{1}{N}NE[\\frac{f(x)}{p(x)}] = \\int f(x)dx$$ 接下来使用蒙特卡洛方法来分解方程(1),使用均匀分布$p(\\phi) = \\frac{1}{2\\pi},p(\\theta) = \\frac{1}{(\\frac{\\pi}{2})} = \\frac{2}{\\pi}$ 构造估计量如下:$$L_o = k_d \\frac{c}{\\pi}\\frac{1}{n_1}\\frac{1}{n_2}\\sum_{i = 1}^{n_1}\\sum_{j = 1}^{n_2}\\frac{L_i(p,\\phi_i,\\theta_j)cos(\\theta_j)sin(\\theta_j)}{p(\\phi)\\cdot p(\\theta)}d\\phi d\\theta$$$$\\Rightarrow L_o = k_d\\frac{c}{\\pi}\\frac{1}{n_1 n_2} 2\\pi \\frac{\\pi}{2}\\sum_{i = 1}^{n_1}\\sum_{j = 1}^{n_2}L_i(p,\\phi_i,\\theta_j)cos(\\theta_j)\\sin(\\theta_j)d\\phi d\\theta$$$$\\Rightarrow L_o = k_d c\\frac{\\pi}{n_1 n_2}\\sum_{i = 1}^{n_1}\\sum_{j = 1}^{n_2}L_i(p,\\phi_i,\\theta_j)cos(\\theta_j)\\sin(\\theta_j)d\\phi d\\theta$$ 实现就显得很简单了,IBL中贴图的每个texel都是一个光源,即提供了$L_i$的数据,代码如下: 1234567891011121314151617181920212223242526272829303132333435363738int phiSampleCount = 100;int thetaSampleCount = 100;float phiDelta = SMath::TWO_PI / phiSampleCount;float thetaDelta = SMath::PI_DIV_2 / thetaSampleCount;#pragma omp parallel for schedule(dynamic)for (int i = 0; i &lt; width; i++){ for (int j = 0; j &lt; height; j++) { float phi = SMath::TWO_PI * i / (float)(width -1); float theta = SMath::PI * j / (float)(height - 1); SVector3f up = SVector3f(SMath::SinRad(theta) * SMath::CosRad(phi), SMath::CosRad(theta), SMath::SinRad(theta) * SMath::SinRad(phi)); SVector3f front = up.z &lt; 0.999f ? SVector3f(0.0f, 0.0f, 1.0f) : SVector3f(0.0f, -1.0f, 0.0f); SVector3f right = SVector3f::Normalize(SVector3f::cross(up, front)); front = SVector3f::Normalize(SVector3f::cross(right, up)); SVector3f irradiance = SVector3f::Zero(); for (float localPhi = 0.0f; localPhi &lt; SMath::TWO_PI; localPhi += phiDelta) { for (float localTheta = 0.0f; localTheta &lt; SMath::PI_DIV_2; localTheta += thetaDelta) { SVector3f localDir = SVector3f(SMath::SinRad(localTheta) * SMath::CosRad(localPhi), SMath::CosRad(localTheta), SMath::SinRad(localTheta) * SMath::SinRad(localPhi)); SVector3f dir = right * localDir.x + up * localDir.y + front * localDir.z; dir.Normalize(); SVector2f uv = CartesianToSpherical(dir); irradiance += image.GetPixel(int(uv.x * (width - 1)), int(uv.y * (height - 1))).xyz() * SMath::CosRad(localTheta) * SMath::SinRad(localTheta); } } irradiance = SMath::PI * irradiance / (float)(phiSampleCount * thetaSampleCount); sIrradianceMap-&gt;SetPixel(i, j, irradiance); }} 以如下环境贴图为例: Irradiance Map如下: Specular IBL对Specular项应用蒙特卡洛积分:$$\\int_\\Omega L_i(p,\\omega_i)f(p,\\omega_i,\\omega_o)(n \\cdot \\omega_i) d\\omega_i \\approx \\frac{1}{N}\\sum_{k = 1}^N\\frac{L_i(p,\\omega_{i})f(p,\\omega_{i},\\omega_{o})(n\\cdot \\omega_{i})}{pdf}$$ UE4中对其进行了一个近似,划分成了两个累加的乘积:$$\\frac{1}{N}\\sum_{k = 1}^N\\frac{L_i(p,\\omega_{i})f(p,\\omega_{i},\\omega_{o})(n\\cdot \\omega_{i})}{pdf} \\approx \\Big(\\frac{1}{N}\\sum_{k = 1}^N L_i(p,\\omega_{i}\\Big )\\Big (\\frac{1}{N}\\sum_{k = 1}^{N}\\frac{f(p,\\omega_{i}, \\omega_{o})(n \\cdot \\omega_{i})}{pdf}\\Big )$$ Pre-Filtered Environment Map对于第一个累加,常用的方案是使用GGX的重要性采样对环境贴图进行卷积计算我们可以针对不同的粗糙度值进行预计算,并将结果保存在mipmap中由于使用了微表面模型,分布的形状将会受到视角的影响,因此,这里假定为各向同性,即$N = V = R$但这也意味着我们从与法线垂直的方向去看表面,无法得到强烈的反射,针对这一点,使用$\\cos(\\omega_i)$进行加权解决 实现如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546for (int miplevel = 0; miplevel &lt; mipNum; miplevel++){ float roughness = (float)miplevel / (float)(mipNum - 1); int cur_width = width &gt;&gt; miplevel; int cur_height = height &gt;&gt; miplevel;#pragma omp parallel for schedule(dynamic) for (int i = 0; i &lt; cur_width; i++) { for (int j = 0; j &lt; cur_height; j++) { float phi = (float)i / (float)(cur_width - 1) * SMath::TWO_PI; float theta = (float)j / (float)(cur_height - 1) * SMath::PI; SVector3f N(SMath::SinRad(theta) * SMath::CosRad(phi), SMath::CosRad(theta), SMath::SinRad(theta) * SMath::SinRad(phi)); N.Normalize(); SVector3f V = N; SVector3f prefilterdColor = SVector3f::Zero(); float sumWeight = 0.0f; // 使用GGX Importance Sampling选择采样点 for (unsigned int isample = 0; isample &lt; sampleNum; isample++) { SVector2f Xi = Hammersley(isample, sampleNum); SVector3f H = ImportanceSampleGGX(Xi, roughness, N); SVector3f L = SVector3f::Normalize(H * 2.0f * dot(V, H) - V); float NdotL = dot(N, L); if (NdotL &gt; 0.0f) { SVector2f sphericalCoordinate = CartesianToSpherical(L); SVector2f uv(sphericalCoordinate.x * (width - 1), sphericalCoordinate.y * (height - 1)); prefilterdColor += image.GetPixel((int)uv.x, (int)uv.y).xyz() * NdotL; sumWeight += NdotL; } } prefilterdColor /= sumWeight; sPrefilterMap-&gt;SetPixel(i, j, prefilterdColor, miplevel); } }} 计算结果如下: Precompute BRDF LUT接着分解第二个累加项:$$\\frac{1}{N}\\sum_{k = 1}^{N}\\frac{f(p,\\omega_{i}, \\omega_{o})(n \\cdot \\omega_{i})}{pdf} = \\frac{1}{N}\\sum_{k = 1}^{N}\\frac{f(p,\\omega_{i}, \\omega_{o})(n \\cdot \\omega_{i}) \\times F(\\omega_{o},\\omega_h)}{pdf \\times F(\\omega_{o},\\omega_h)}$$ $$\\because F(\\omega_o, \\omega_h) = F_0 + (1 - F_0)(1 - \\omega_o \\cdot \\omega_h)^5$$ $$\\Rightarrow \\frac{1}{N}\\sum_{k = 1}^{N}\\frac{f(p,\\omega_{i}, \\omega_{o})(n \\cdot \\omega_{i}) \\times (F_0 (1 - (1 - \\omega_{o} \\cdot \\omega_h)^5) + (1 - \\omega_{o} \\cdot \\omega_h)^5)}{pdf \\times F(\\omega_{o},\\omega_h)}$$ $$\\Rightarrow \\frac{F_0}{N}\\sum_{k = 1}^{N} \\frac{f(p,\\omega_{i}, \\omega_{o})(n\\cdot \\omega_{i}) \\times (1 - (1 - \\omega_{o} \\cdot \\omega_h)^5)}{pdf \\times F(\\omega_{o}, \\omega_h)} + \\\\\\frac{1}{N}\\sum_{k = 1}^{N}\\frac{f(p,\\omega_{i},\\omega_{o}) (n\\cdot \\omega_{i}) \\times (1 - \\omega_{o} \\cdot \\omega_h)^5}{pdf \\times F(\\omega_{o},\\omega_h)} \\tag{2}$$ 由于我们使用的是微表面模型:$$f(p,\\omega_i,\\omega_o) = \\frac{D(\\omega_h)F(\\omega_o,\\omega_h)G(\\omega_i,\\omega_o)}{4(\\omega_i \\cdot n)(\\omega_o \\cdot n)}$$ GGX重要性采样的PDF为:$$pdf = \\frac{D(\\omega_h)(\\omega_h \\cdot n)}{4 (\\omega_o \\cdot \\omega_h)}$$ 因此:$$\\frac{f(p,\\omega_i,\\omega_o)(\\omega_i \\cdot n)}{pdf \\times F(\\omega_o,\\omega_h)} = \\frac{D(\\omega_h)F(\\omega_o,\\omega_h)G(\\omega_i,\\omega_o)(\\omega_i \\cdot n)}{4(\\omega_i \\cdot n)(\\omega_o \\cdot n)} \\times \\frac{4 (\\omega_o \\cdot \\omega_h)}{D(\\omega_h)(\\omega_h \\cdot n) F(\\omega_o,\\omega_h)}$$$$\\Rightarrow = \\frac{G(\\omega_i,\\omega_o)(\\omega_o \\cdot \\omega_h)}{(\\omega_o \\cdot n)(\\omega_h \\cdot n)}$$ 代入(2)式可得:$$\\frac{F_0}{N}\\sum_{k = 1}^N \\frac{G(\\omega_i,\\omega_o)(\\omega_o \\cdot \\omega_h)(1 - (1 - \\omega_o \\cdot n)^5)}{(\\omega_o \\cdot n)(\\omega_h \\cdot n)} + \\frac{1}{N}\\sum_{k = 1}{N}\\frac{G(\\omega_i,\\omega_o)(\\omega_o \\cdot \\omega_h) (1 - \\omega_o \\cdot h)^5}{(\\omega_o \\cdot n)(\\omega_h \\cdot n)}$$ 因此可以以roughness与$(\\omega_o \\cdot n)$作为变量来预计算上述方程,以roughness,$(\\omega_o \\cdot n)$为行列得到预计算的BRDF查找表代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546SVector2f IntegrateBRDF(float roughness, float NdotV){ SVector2f V; V.x = sqrt(1.0f - NdotV * NdotV); V.y = NdotV; V.z = 0.0f; float A = 0, B = 0; SVector3f N = Svector3f(0.0f,1.0f,0.0f); unsigned int numSamples = 1024; for(unsigned int i = 0; i &lt; numSamples; i++) { SVector2f Xi = Hammersley(i, numSamples); SVector3f H = ImportanceSampleGGX(Xi, roughness, N); SVector3f L = SVector3f::Normalize(2 * dot(V,H) * H - V); float NdotL = SMath::clamp(L.y, 0.0f, 1.0f); float NdotH = SMath::clamp(H.y, 0.0f, 1.0f); float VdotH = SMath::clamp(dot(V,H), 0.0f, 1.0f); if(NdotL &gt; 0.0f) { float G = G_Smith(roughness, NdotV, NdotL); float G_Vis = G * VdotH / (NdotH * NdotV); float Fc = pow(1 - VdotH, 5); A += (1 - Fc) * G_Vis; B += Fc * G_Vis; } } return SVector2f(A / numSamples, B / numSamples);}for(int j = 0; j &lt; height; j++){ for(int i = 0; i &lt; width; i++) { float NdotV = i / (float)(width - 1); float roughness = j / (float)(height - 1); SVector2f brdf = IntegrateBRDF(roughness, NdotV); sBRDFLutMap-&gt;SetPixel(i, height - 1 -j , brdf.x, brdf.y, 0.0f, 1.0f); }} 预计算结果如下: 最终Specular IBL计算如下: 123456789float3 irradiance = IrradianceMap.Sample(samplerIrradiace, CartesianToSpherical(N)).rgb;float3 diffuse = irradiance * albedo;const float MAX_REFLECTION_LOD = 10.0;float3 prefilteredColor = prefilterMap.SampleLevel(samplerPrefilter, CartesianToSpherical(R), roughness * MAX_REFLECTION_LOD).rgb;float2 envBRDF = BRDFLutMap.Sample(samplerBRDFLut, float2(NdotV, roughness)).rg;float3 specularIBL = prefilteredColor * (F * envBRDF.x + envBRDF.y);float3 ambient = (kd * diffuse + specular) * AO; 实现代码可参考这里,效果如下: Reference Real Shading in Unreal Engine 4 Diffuse Irradiance Specular IBL","link":"/IBL/"},{"title":"debug-example","text":"IOS PSO Async Compile Crash崩溃堆栈崩溃链接： 调用代码： 崩溃分析使用XCode Attach到IOS进程后，打开汇编面板： 将会看到对BlendState的地址解引用后得到的值为0x60000000，说明内存被写坏或者释放了 在BlendState创建时下个断点，获取BlendState的地址，然后对该地址下内存断点： 1watchpoint set expression -- 地址 继续运行后触发内存断点，堆栈如下图： 最终确定原因为：BlendState创建后返回带引用的对象，GraphicsInitializer接收时并未加引用，导致出作用域后就被释放了 修复UE官方修复CL：11574776，对BlendState, DepthStencilState，RasterizationState做了个池，并AddRef","link":"/IOSPSOAsyncCompileCrash/"},{"title":"Microfacet Theory","text":"微面元理论微面元理论认为粗糙表面是由细小的微面组成的,每个微面元都满足完美镜面反射 $$\\omega_h = \\omega_i \\hat{+} \\omega_o$$ $$d\\Phi_h = L_i(\\omega_i)d\\omega_i dA^{\\perp}(\\omega_h) = L_i(\\omega_i)d\\omega_i cos\\theta_h dA(\\omega_h)$$ $$dA(\\omega_h) = D(\\omega_h)d\\omega_h dA$$ $D(\\omega_h)$:法线分布项,描述微面元的法线为$\\omega_h$的比例,只有法线为$\\omega_h$的才能被看见 $$\\Rightarrow d\\Phi_h = L_i(\\omega_i)d\\omega_i cos\\theta_h D(\\omega_h)d\\omega_h dA$$ 假设每个微面元都各自按照Fresnel&apos;s Law反射光线 $$\\Rightarrow d\\Phi_o = F_r(\\omega_o)d\\Phi_h$$ $$\\because L(\\omega_o) = \\frac{d\\Phi_o}{d\\omega_o cos\\theta_o dA}$$ $$\\therefore L(\\omega_o) = \\frac{F_r(\\omega_o)L_i(\\omega_i)d\\omega_i cos\\theta_h D(\\omega_h) d\\omega_h dA}{d\\omega_o cos\\theta_o dA}\\tag{1}$$ 接下来计算$\\frac{d\\omega_h}{d\\omega_i}$,考虑基于$\\omega_o$的球坐标系,如下图: $$\\frac{d\\omega_h}{d\\omega_i} = \\frac{sin\\theta_h d\\theta_h d\\phi_h}{sin\\theta_i d\\theta_i d\\phi_i}$$ $$\\because \\theta_i = 2\\theta_h$$ $$\\therefore \\frac{d\\omega_h}{d\\omega_i} = \\frac{sin\\theta_h d\\theta_h d\\phi_h}{sin(2\\theta_h)2d\\theta_h d\\phi_h} = \\frac{sin\\theta_h}{4sin\\theta_h cos\\theta_h} = \\frac{1}{4cos\\theta_h}$$ $$\\Rightarrow \\frac{d\\omega_h}{d\\omega_i} = \\frac{1}{4cos\\theta_h} = \\frac{1}{4\\omega_i \\cdot \\omega_h} = \\frac{1}{4\\omega_o \\cdot \\omega_h}$$$$\\Rightarrow \\frac{d\\omega_h}{d\\omega_o} = \\frac{1}{4cos\\theta_h} = \\frac{1}{4\\omega_i \\cdot \\omega_h} = \\frac{1}{4\\omega_o \\cdot \\omega_h}$$ 代入(1)式:$$\\Rightarrow L(\\omega_o) = \\frac{F_r(\\omega_o)L_i(\\omega_i)D(\\omega_h)d\\omega_i}{4cos\\theta_o}$$ $$\\because L(\\omega_o) = L(\\omega_i) f_r(p,\\omega_i, \\omega_o)cos\\theta_i d\\omega_i$$ $$\\therefore f_r(p,\\omega_i,\\omega_o) = \\frac{L(\\omega_o)}{L(\\omega_i) cos\\theta_i d\\omega_i} = \\frac{F_r(\\omega_o)D(\\omega_h)}{4cos\\theta_i cos\\theta_o} = \\frac{F_r(\\omega_o)D(\\omega_h)}{4(n\\cdot l)(n \\cdot v)}$$ 再乘上一个几何衰减项G,用于描述微面元被遮挡或者处于阴影中的比例 $$\\Rightarrow f_r(p,\\omega_i,\\omega_o) = \\frac{F_r(\\omega_o)D(\\omega_h)G(\\omega_i,\\omega_o)}{4cos\\theta_o cos\\theta_i}$$ 接下来讲下D,F,G的常用实现方案 法线分布项GGX$$D(h) = \\frac{\\alpha^2}{\\pi((n\\cdot h)^2(\\alpha^2 - 1) + 1)^2}$$$$\\alpha = roughness^2$$ roughness: 粗糙度 1234567float D(float alpha, float NdotH){ float alphaSqr = sqr(alpha); float denominator = sqr(NdotH) * (alphaSqr - 1.0f) + 1.0f; float D = alphaSqr / (PI * sqr(denominator)); return D;} 几何衰减项SmithSmith函数对G做了一个近似,即假设入射遮挡与出射遮挡是不相关的,因此可以被分离开来 $$G(l,v,h) = G_1(n,l)G_1(n,v)$$$$G_1(n,v) = \\frac{n\\cdot v}{(n\\cdot v)(1 - k) + k}$$$$k = \\frac{(Roughness + 1)^2}{8}$$ 实现: 12345678910111213141516171819float K(float _Roughness){ float modifiedRoughness = _Roughness + 1; return sqr(modifiedRoughness) / 8;}float G1(float k, float NdotV){ return NdotV / (NdotV * (1 - k) + k);}float G_Smith(float _Roughness, float NdotL, float NdotV){ float k = K(_Roughness); float G1L = G1(k, NdotL); float G1V = G1(k, NdotV); float G = G1L * G1V; return G;} 菲涅尔项Shclick原始的菲涅尔公式计算比较复杂,一般都是使用如下方程进行近似: $$F_{schlick}(F_0,l,h) = F_0 + (1 - F_0)(1-(l\\cdot h))^5$$ $F_0$: 入射光垂直于表面时的菲涅尔反射率值,也称之为镜面颜色 $$F(0) = (\\frac{\\eta_i - \\eta_o}{\\eta_i + \\eta_o})^2$$ 以下为常见材质的F(0)值 Material F(0) (Linear) F(0) (sRGB) Color Water 0.02,0.02,0.02 0.15,0.15,0.15 xx{background-color:rgb(38.25,38.25,38.25);}         Plastic / Glass (Low) 0.03,0.03,0.03 0.21,0.21,0.21 yy{background-color:rgb(53.55,53.55,53.55);}         Plastic High 0.05,0.05,0.05 0.24,0.24,0.24 zz{background-color:rgb(61.2,61.2,61.2);}         Glass (High) / Ruby 0.08,0.08,0.08 0.31,0.31,0.31 qq{background-color:rgb(79.05,79.05,79.05);}         Diamond 0.17,0.17,0.17 0.45,0.45,0.45 ww{background-color:rgb(114.75,114.75,114.75);}         Iron 0.56,0.57,0.58 0.77,0.78,0.78 tt{background-color:rgb(196.35,198.9,198.9);}         Copper 0.95,0.64,0.54 0.98,0.82,0.76 hh{background-color:rgb(249.9,209.1,193.8);}         Gold 1.00,0.71,0.29 1.00,0.86,0.57 jj{background-color:rgb(255,219.3,145.35);}         Aluminum 0.91,0.92,0.92 0.96,0.96,0.97 kk{background-color:rgb(244.8,244.8,247.35);}         Silver 0.95,0.93,0.88 0.98,0.97,0.95 ll{background-color:rgb(249.9,247.35,242.25);}         代码实现: 1234float SchlickFresnel(float4 SpecColor, float lightDir, float3 halfVector){ return SpecColor + (1 - SpecColor) * pow(1 - dot(lightDir, halfVector), 5);} Reference Physically-Based Shading Models inFilm and Game Production","link":"/Microfacet-BRDF/"},{"title":"preintegrated skin rendering","text":"预积分皮肤渲染本文主要记录预积分皮肤渲染的思路以及一些要点解析 算法思路正常而言次表面散射通常需要模拟光线通过皮肤或收集周边皮肤位置的光照贡献。 屏幕空间扩散(TSD)的方案就是通过在纹理空间保存入射光信息，并通过模糊操作实现扩散 这种渲染方式需要多Pass且性能不高。而预积分的方案则可以在局部着色模型下实现，无需多Pass 首先引入扩散剖面(Diffusion Profile)的概念，其表示有多少光照扩散到入口点一定距离的皮肤着色点 预积分模拟散射效果主要分为以下三个层面： 光照模型 表面细节 光照遮挡(即阴影) 首先假设一个均匀方向光完全照射一块平整的皮肤，在该特定情况下，由于入射光处处相等，不会发生可见的散射 只有三种情况下会导致可见的散射： 非平整的面元，即存在曲率变化 法线贴图产生的凹凸 光线遮挡 光照模型层面首先考虑平滑且弯曲的表面，会由于表面弯曲而导致光照发生透射，产生散射现象 而两个主要因素为： $N\\cdot L$的衰减，导致入射光不一致 表面曲率 首先定义一个皮肤的渲染模型： 以下推导搬运自幽玄大佬的知乎文章： N为表面法线，L为入射光方向，P为法线方向与球面的交点， $\\theta$为N与L的夹角 假设P会且仅会受到法线正方向半径为r的半球表面各点的散射光影响 假设L方向的光的辐射亮度为1， 在APB半球空间的任意一点Q，其直接光照的亮度为：$$L_Q = 1\\cdot dot(OQ, OL) = cos(x+\\theta)$$假设Q点对P点的散射率为$q(x)$，$x$为OQ与法线的夹角，设Q所占半球的弧度为$\\Delta{x}$，则Q对P的贡献为：$$L_Q \\times q(x) \\times \\Delta{x} = cos(x+\\theta)q(x)\\Delta{x}$$对于整个半球积分：$$\\int_{-\\pi}^cos(x+\\theta)q(x)\\Delta{x}$$根据能量守恒，$q(x)$作为散射率函数，需要满足整个球面积分的结果为1：$$\\int_{-{\\pi}}^{\\pi}q(x) = 1$$这里我们选用扩散剖面作为散射率函数，扩散剖面是一个关于距离的函数，且其积分并不一定为1$$\\because d = 2rsin(\\frac{x}{2}) \\\\Rightarrow R(d) = R(2rsin(\\frac{x}{2}))$$但是我们可以假设如下关系：$$q(x) = kR(d) = kR(2rsin(\\frac{x}{2}))$$因此：$$\\int_{-{\\pi}}^q(x) = \\int_{-{\\pi}}^kR(d) = k\\int_{-{\\pi}}^R(d) = 1$$求解k:$$k = \\frac{1}{\\int_{-{\\pi}}^R(d)}$$因此：$$q(x) = \\frac{R(d)}{\\int_{-{\\pi}}^R(d)}$$代入3式中：$$\\int_{-{\\pi}}^\\frac{cos(x+\\theta)R(d)}{\\int_{-{\\pi}}^R(d)}\\Delta{x}$$ 由于$\\int_{-{\\pi}}^R(x)$为常数，因此上式等价于：$$\\frac{\\int_{-{\\pi}}^cos(x+\\theta)R(d)\\Delta{x}}{\\int_{-{\\pi}}^R(d)}$$ 结合(5)式可得：$$\\frac{\\int_{-{\\pi}}^cos(x+\\theta)\\cdot R(2rsin(\\frac{x}{2}))\\Delta{x}}{\\int_{-{\\pi}}^R(2rsin(\\frac{x}{2}))}$$ 高斯函数使用：$$G(v, r) = \\frac{1}{\\sqrt{2\\pi v }}e^{-\\frac{r^2}{2v}}$$因此上述高斯和等价于： 1234567G(r) = G(0.0064 * 1.414, r) * float3(0.233, 0.455, 0.649) +G(0.0484 * 1.414, r) * float3(0.100, 0.336, 0.344) +G(0.1870 * 1.414, r) * float3(0.118, 0.198, 0.000) +G(0.5670 * 1.414, r) * float3(0.113, 0.007, 0.007) +G(1.9900 * 1.414, r) * float3(0.358, 0.004, 0.000) +G(7.4100 * 1.414, r) * float3(0.078, 0.000, 0.000); 左图表示使用上述高斯和时红，绿，蓝光在皮肤下的扩散剖面可视化 右图表示如何对散射效果进行预积分","link":"/Preintegrated-Skin/"},{"title":"Radiometry","text":"光模型图形学中使用最常用的是几何光学,该模型中,物体的尺寸远大于光的波长几何光学中,衍射,干涉以及极化现象是不会发生的. 几何光学假定光是发射,反射以及透射,并对于光的行为做出如下假设: 直线传播 传播速度无限快,用于保证场景光能的温态分布 不受其它因素的影响,如重力,磁场 辐射度全局光照的目的就是计算场景光能的稳态分布,因此涉及到一些光的物理量 通量(Flux)辐射通量也称之为功率,为每单位时间通过一个表面或区域的所有能量，单位为焦尔每秒J/s或瓦W,通常用符号$\\Phi$ 下图中通过两个球面的通量是一样的 辐照度(Irradiance)辐照度为每单位面积上的入射辐射通量,单位为$W/m^2$ $$E = \\frac{d\\Phi}{dA}$$ 辐射出射度(辐射度Radiosity)辐射出射度(M)也称之为辐射度(B),为每单位面积上的出射辐射通量,单位为$W/m^2$ $$M=B=\\frac{d\\Phi}{dA}$$ 辐射率辐射率为每单位投影面积每单位立体角上的辐射通量 $$L = \\frac{d^2\\Phi}{d\\omega dA^{\\perp}}=\\frac{d^2\\Phi}{d\\omega dA\\cos\\theta}$$ 对着半球上一块区域的立体角$\\Omega$定义为区域面积除以半球半径的平方,即: $$\\Omega = \\frac{A}{r^2}$$ 各个量的关系$$\\begin{align}\\Phi \\quad &amp;= \\quad \\int_A\\int_{\\Omega}L(x\\rightarrow \\Theta)\\cos\\theta d\\omega_{\\Theta}dA_x \\notag \\\\[2ex]E(x) \\quad &amp;= \\quad \\int_\\Omega L(x \\leftarrow \\Theta)\\cos\\theta d\\omega_\\Theta \\notag \\\\[2ex]B(x) \\quad &amp;= \\quad \\int_\\Omega L(x \\rightarrow \\Theta)\\cos\\theta d\\omega_\\Theta \\notag \\\\\\end{align}$$ 辐射率属性沿路径可交换 $L(x \\rightarrow y) = L(y \\leftarrow x)$表示从点x向y发射的辐射率等于由点x到达点y的辐射率(注意一个是发射，一个是到达) 即假定光是在真空中传播,假设微分通量$d\\Phi$离开微分表面$dA_x$到达微分表面$dA_y$,那么: $$\\begin{align}L(x \\rightarrow y) &amp;= \\frac{d^2\\Phi}{(\\cos\\theta_x dA_x)d\\omega_{x\\leftarrow dA_y}} \\notag\\\\[2ex]d^2\\Phi &amp;= L(x \\rightarrow y)cos\\theta_x d\\omega_{x\\leftarrow dA_y}dA_x\\notag\\end{align}$$ $d\\omega_{x\\leftarrow dA_y}$表示从x看对着$dA_y$的立体角 $$\\begin{align}L(y\\leftarrow x) &amp;= \\frac{d^2\\Phi}{(\\cos\\theta_y dA_y)d\\omega_{y\\leftarrow dA_x}dA_y} \\notag\\\\[2ex]d^2\\Phi &amp;= L(y \\rightarrow x)cos\\theta_y d\\omega_{y \\leftarrow dA_x}dA_y\\notag\\end{align}$$ 微分立体角为: $$d\\omega_{x \\leftarrow dA_y} = \\frac{cos\\theta_y dA_y}{r^2_{xy}}$$ $$d\\omega_{y \\leftarrow dA_x} = \\frac{cos\\theta_x dA_x}{r^2_{xy}}$$ 假设没有外部光源提供能量到达$dA_y$,且位于真空,不存在能量损失.根据能量守恒: $$\\begin{align}L(x \\rightarrow y)cos\\theta_x d\\omega_{x\\leftarrow dA_y}dA_x &amp;= L(y\\leftarrow x)cos\\theta_y d\\omega_{y \\leftarrow dA_x}dA_y\\notag\\\\[2ex]L(x \\rightarrow y)cos\\theta_x \\frac{cos\\theta_y dA_y}{r^2_{xy}}dA_x &amp;= L(y \\leftarrow x)cos\\theta_y \\frac{cos\\theta_x dA_x}{r^2_{xy}}dA_y\\notag\\\\\\end{align}$$ $$\\Rightarrow L(x \\rightarrow y) = L(y \\leftarrow x)$$ 该性质只在两个表面之间没有可以吸收,散射能量的介质时成立 传感器,例如相机,人眼,对辐射敏感入射到传感器上的辐射与传感器的响应成正比,比例常熟取决于传感器的几何形状 这两个属性解释了为何感知的物体颜色与亮度不会随着距离发生变化 传输理论假设光子的密度为$p(x)$,即在点x处每单位体积的光子数为$p(x)$,则$dV$中的光子数为$p(x)dV$ 那么假设光子穿过截面$dA$,持续时间为$dt$,光子的运动方向与截面法线的夹角为$\\theta$,且已知光速为$c$ 因此，通过$dA$的总光子数为: $$N = p(x,\\omega,\\lambda)cdtdA\\cos\\theta d\\omega d\\lambda$$ $d\\omega$为微分方向,$\\lambda$为波长 通量为单位时间的光子能量总数，因此： $$\\Phi \\propto p(x,\\omega,\\lambda)dA\\cos\\theta d\\omega d\\lambda$$ $$\\frac{\\Phi}{dA\\cos\\theta d\\omega} \\propto p(x,\\omega,\\lambda)d\\lambda$$ 光子的能量为:$E=\\frac{hc}{\\lambda}$ 辐射率被定义为每单位体积的辐射能: $$L(x,\\omega)=\\int p(x,\\omega,\\lambda)h\\frac{c}{\\lambda}d\\lambda$$ 因此,可见辐射率不仅依赖位置,方向,还依赖波长,当显式指定了波长时,辐射率称之为光谱辐射 辐射率是将光谱辐射对所有的可见光波长积分： $$L(x\\rightarrow \\Theta) = \\int_{spectrum}L(x\\rightarrow \\Theta,\\lambda)d\\lambda$$ 全局光照中对于波长的依赖往往都是隐式假定，不会显式指出. 发射光全局光照的计算需要为每种光源指出以下三种分布: 空间分布:理想化的空间分布为点光源,更普遍的是区域光源 方向分布:由灯具的形状决定 频谱分布:虽然光的频谱分布可以精确模拟,但出于效率考虑普遍使用RGB","link":"/Radiometry/"},{"title":"VPS SSH Git Config","text":"本地配置GitGit For Windows下载路径Git for Windows 环境配置添加系统变量GIT_HOME 在系统变量PATH中加入如下项 设置完毕之后，重开一个CMD窗口，输入git命令，出现下图表示配置正确 服务端配置Git连接上VPS后，执行以下命令 安装Git12yum updateyum install git 新建Git用户1adduser git 此命令将会新建用户git并创建/home/git作为该用户的目录 加入sudoer切换到root用户，输入如下命令 12chmod 740 /etc/sudoersvim /etc/sudoers 在列出的文本中找到如下内容 1root ALL=(ALL) ALL 在后面新增一行 1git ALL=(ALL) ALL 再执行如下命令 1chmod 440 /etc/sudoers 配置SSH登录打开CMD窗口，进入用户目录下的.ssh目录，路径如下： 1C:\\Users\\yourname\\.ssh 输入以下命令 1ssh-keygen -t rsa 然后一路回车即可, 在~/.ssh目录中将会生成id_rsa和id_rsa.pub两个文件 将公钥传送到服务端切换到git用户 1su git 新建authorized_keys文件，并将公钥复制进去 123mkdir -p ~/.sshtouch ~/.ssh/authorized_keysvi ~/.ssh/authorized_keys 然后将id_rsa.pub中的数据粘贴到authorized_keys中 或者在VPS上以git用户执行 12mkdir -p ~/.sshcat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 本地的~为你的用户目录：C:\\Users\\yourname 服务端以git用户登陆时，~表示\\home\\git 因此，若是不切到git用户的话，上述命令改为 12mkdir -p /home/git/.sshcat ~/.ssh/id_rsa.pub &gt;&gt; /home/git/.ssh/authorized_keys 现在可以在git bash中通过以下命令免密登陆VPS： 1ssh -p port git@ip port为你的服务端ssh端口，ip为你服务器地址，如: 1ssh -p 1234 git@34.15.21.145 若是依然无法连接，检查服务器的/etc/ssh/sshd_config这个文件，以下几行的#注释是否移除 123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 若是ssh提示需要登录密码，则切到git用户，输入以下命令: 123chmod o-w ~/chmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys 重启ssh 1/etc/init.d/sshd restart","link":"/VPS-SSH-Git-Config/"},{"title":"character wrinkle","text":"简介将表情与区域掩码相关联,使用表情权重作为正常法线与皱纹法线的过渡权重通过颜色值来区分皱纹区域 算法描述 根据表情与掩码的关联,计算出当帧每个皱纹区域的权重值 根据采样皱纹掩码图计算当前像素位于哪个皱纹区域并计算最终权重 使用权重值在原始法线与皱纹法线之间插值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859cbuffer wrinkle_weight : register(b0){ float3 red_weights; float3 green_weights; float3 blue_weights; float3 alpha_weights;};Texture2D baseNormal : register(t0);Texture2D wrinkleMask : register(t1);Texture2D wrinkleNormal : register(t2);SamplerState baseSampler : register(s0);SamplerState maskSampler : register(s1);SamplerState wrinkleSampler : register(s2);float computeWeight(uint4 mask){ int rIdx = mask.r / 90; int rOffset = value % 90; float rWeight = step(offset , 75) * clamp(offset * 0.014f , 0.0f , 1.0f) * red_Weight[rIdx]; int gIdx = mask.g / 90; int gOffset = value % 90; float gWeight = step(offset , 75) * clamp(offset * 0.014f , 0.0f , 1.0f) * greend_weight[gIdx]; int bIdx = mask.b / 90; int bOffset = value % 90; float bWeight = step(offset , 75) * clamp(offset * 0.014f , 0.0f , 1.0f) * blue_Weight[bIdx]; int aIdx = mask.a / 90; int aOffset = value % 90; float aWeight = step(offset , 75) * clamp(offset * 0.014f , 0.0f , 1.0f) * alpha_Weight[aIdx]; return max(rWeight , max(gWeight , max(bWeight , aWeight)));}PixelOut ps_main(PixelIn input){ PixelOut out; float4 maskColor = wrinkleMask.Sample(maskSampler, input.texcoord); clip(maskColor.r + maskColor.g + maskColor.b + maskColor.a - 0.01f); uint4 uMask = maskColor * 255; float weight = computeWeight(uMask); clip(weight - 0.001f); float3 normalColor = baseNormal.Sample(baseSampler , input.texcoord); normalColor = NormalMapping(input.Normal, input.Tangent, input.Binormal, normalColor); float3 wrinkleNormalColor = wrinkleNormal.Sample(wrinkleSampler,input.Texcoord); wrinkleNormalColor = NormalMapping(input.Normal, input.Tangent, input.Binormal, wrinkleNormalColor); out.Normal = lerp(normalColor , wrinkleNormalColor , weight); return out;} 掩码图资源制作 未压缩DDS 套索工具关闭抗锯齿 不使用颜色管理,避免Gamma的影响 边缘过渡使用内发光特效实现 掩码图尺寸使用$512\\times 512$即可,不需太大 BC3 Linear RGBA各三个颜色段:$0~75$,$90~165$,$180~255$ 注意事项 掩码图点采样:D3D11_FILTER_MIN_MAG_MIP_POINT 掩码图不需要MipMap More InfoCryEngine Wrinkle Map Tutorial","link":"/character-wrinkle/"},{"title":"color grading","text":"简介简单来说就是颜色查找表,以颜色值作为3D纹理的纹理坐标,利用插值与色阶实现全色映射 相比HSV调色等具有更强的表现力,可由美术进行色彩,对比度,亮暗等等方面的控制 适用场合 用于做后处理,改变场景的风格 换肤等 算法描述以像素值作为纹理坐标采样3D纹理得到最终的颜色值 12345678910111213Texture2D origTexture : register(t0);SamplerState origSampler : register(s0);Texture3D lutTexture : register(t1);SamplerState lutSampler : register(s1);float4 ps_main(PixelIn input) : SV_TARGET{ float4 color = origTexture.Sample(origSampler, input.texcoord); color.rgb = lutTexture.Sample(lutSampler, input.texcoord).rgb; return color;} 资源要求 3D纹理:下面将此3D纹理称之为LUT. 当以R8G8B8A8来存储LUT的话,$256\\times 256\\times 256$的查找表大小为64M. 因此,通常是将其划分为32阶,也就是尺寸为$32\\times 32\\times 32$.大小为128k,实际应用中精度足够,内存占用也不大 资源制作原始色阶首先制作一张原始色阶图,下图为256*128的原始色阶图,包含32阶的所有颜色值 生成算法如下: 123456789101112131415161718192021222324void generate_pixels(color* pixels, const bitmap_info&amp; info, int size, int downscale_shift){ int blue_stride = info.width / size; for (int row = 0; row &lt; info.height; row++) { int g = row % size; int offset = (int)(row / size) * blue_stride; for (int col = 0; col &lt; info.width; col++) { int r = col % size; int b = offset + col / size; auto&amp; c = pixels[row * info.width + col]; c.r = r &lt;&lt; downscale_shift; c.g = g &lt;&lt; downscale_shift; c.b = b &lt;&lt; downscale_shift; } }} 调节图像假设原图为A,希望将其变换为B.首先将原始色阶图置于图像右下角,另存为src.bmp 然后开始P图,直到满意为止,针对图像的个别区域P图无意义,需要应用到全图.如下: 将P好的图像另存为dst.bmp 接下来通过两张图像右下角的色阶图来提取LUT. LUT生成 从src.bmp和dst.bmp提取右下角色阶区域的像素值 以src.bmp的颜色值计算LUT的索引,dst.bmp对应处的颜色值作为LUT的值 填充3D纹理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* size : 色阶值 row/col_offset : 右下角色阶区域像素偏移 downscale_shift : 将256个色值转换到指定色阶,如32阶,则右移3位 */struct accColor{ unsigned int r = 0; unsigned int g = 0; unsigned int b = 0;};struct color{ unsigned char r = 0; unsigned char g = 0; unsigned char b = 0; unsigned char a = 255;};void lut_set(const color&amp; src_color, const color&amp; dst_color, int size, accColor* lut, int* acc_count, int downscale_shift){ int index = (src_color.b &gt;&gt; downscale_shift) * size * size + (src_color.g &gt;&gt; downscale_shift) * size + (src_color.r &gt;&gt; downscale_shift); accColor&amp; pixel = lut[index]; pixel.r += dst_color.r; pixel.g += dst_color.g; pixel.b += dst_color.b; acc_count[index]++;}bool average_lut(const accColor* acc_pixels, color* lut_pixels, const int* acc_count, int total_size){ bool all_valid = true; for (int i = 0; i &lt; total_size; i++) { if (acc_count[i] &gt; 0) { lut_pixels[i].r = acc_pixels[i].r / acc_count[i]; lut_pixels[i].g = acc_pixels[i].g / acc_count[i]; lut_pixels[i].b = acc_pixels[i].b / acc_count[i]; } else { all_valid = false; break; } } return all_valid;}bool lut_generate(const char* src_filename, const char* dst_filename, const char* lut_filename, int size){ ... int total_size = size * size * size; accColor* acc_pixels = new accColor[total_size]; int* acc_count = new int[total_size]; memset(acc_count, 0, total_size * sizeof(int)); for (int irow = row_offset; irow &lt; src_info.height; irow++) { for (int icol = col_offset; icol &lt; src_info.width; icol++) { const color&amp; src_color = src_pixels[irow* src_info.width + icol]; const color&amp; dst_color = dst_pixels[irow* src_info.width + icol]; lut_set(src_color, dst_color, size, acc_pixels, acc_count, right_shift); } } color* lut_pixels = new color[total_size]; if (!average_lut(acc_pixels, lut_pixels, acc_count, total_size)) return false; write_dds(lut_filename, lut_pixels, size); ... return true;} src用于计算3维数组的索引值,dst提供3维数组的数据 之所以添加accColor这个结构是因为当原始色阶图颜色数超出$size^3$时,会有多个颜色映射到3维数组的同一个元素,此时需要先累加再求平均 当然,如果使用前面给出的色阶图或者按照提供的算法生成不会出现此情况 注意事项 生成查找表纹理时,输入源必须是未压缩的,保证$32\\times 32 \\times 32$每个元素都能填充值 3D查找纹理不需要生成MipMap 采用双线性采样,即D3D11_Filter_MIN_MAG_LINEAR_MIP_POINT 寻址模式:D3D11_TEXTURE_ADDRESS_BORDER,BorderColor:(0.0f,0.0f,0.0f,0.0f) 工具tool source code 此工具仅支持24位未压缩的版本的BMP. More InfoUE4 Color Grading","link":"/color-grading/"},{"title":"compute refract direction","text":"Snell’s Law$$\\begin{align}\\eta{_1} \\sin(\\theta_1) &amp;\\quad = \\eta{_2}\\sin(\\theta{_2}) &amp; n &amp;\\quad = (0,1) \\notag \\\\[2ex]L\\qquad &amp;\\quad = (-\\sin(\\theta_1) , \\cos(\\theta_1)) &amp; T &amp;\\quad = (\\sin(\\theta_2) , -\\cos(\\theta_2))\\notag\\end{align}$$ 设:$$\\overrightarrow{T} = x \\times \\overrightarrow{L} + y \\times \\overrightarrow{n}$$ $$\\begin{align}\\Rightarrow&amp; \\begin{cases}&amp;\\sin(\\theta_2) &amp;= &amp;\\quad -\\sin(\\theta_1) \\times x + 0 \\times y \\notag \\\\[2ex]&amp;-\\cos(\\theta_2) &amp;= &amp;\\quad \\cos(\\theta_1) \\times x + 1 \\times y \\notag\\end{cases} \\\\[2ex]\\Rightarrow&amp; \\begin{cases}x &amp;= -\\frac{\\sin(\\theta_2)}{\\sin(\\theta_1)} \\notag \\\\[2ex]y &amp;= \\cos(\\theta_1) * \\frac{\\sin(\\theta_2)}{\\sin(\\theta_1)} - \\cos(\\theta_2) \\notag\\end{cases}\\end{align}$$ $$\\begin{align}\\Rightarrow\\overrightarrow{T} &amp;= -\\frac{\\sin(\\theta_2)}{\\sin(\\theta_1)} \\times \\overrightarrow{L} + (\\cos(\\theta_1) \\times \\frac{\\sin(\\theta_2)}{\\sin(\\theta_1)} - \\cos(\\theta_2)) \\times \\overrightarrow{n} \\notag \\\\[2ex]\\because \\cos(\\theta_2) &amp;= \\sqrt{1 - \\sin^2(\\theta_2)} \\notag \\\\&amp;= \\sqrt{1 - \\frac{\\sin^2(\\theta_2)}{\\sin^2(\\theta_1)}(1 - \\cos^2(\\theta_1))} \\notag \\\\&amp;= \\sqrt{1 - \\frac{\\sin^2(\\theta_2)}{\\sin^2(\\theta_1)}(1 - (\\overrightarrow{L} \\cdot \\overrightarrow{n})^2)}\\notag\\end{align}$$ $$\\begin{align}\\Rightarrow \\overrightarrow{T} &amp;= -\\frac{\\sin(\\theta_2)}{\\sin(\\theta_1)} \\times \\overrightarrow{L} + (\\cos(\\theta_1) \\times \\frac{\\sin(\\theta_2)}{\\sin(\\theta_1)} - \\sqrt{1 - \\frac{\\sin^2(\\theta_2)}{\\sin^2(\\theta_1)}(1 - (\\overrightarrow{L} \\cdot \\overrightarrow{n})^2)}) \\times \\overrightarrow{n}\\notag \\\\[2ex]&amp;= -\\frac{\\eta_1}{\\eta_2} \\times \\overrightarrow{L} + \\overrightarrow{n}(\\frac{\\eta_1}{\\eta_2}(\\overrightarrow{L} \\cdot \\overrightarrow{n}) - \\sqrt{1 - \\frac{\\eta_1^2}{\\eta_2^2}(1 - (\\overrightarrow{L} \\cdot \\overrightarrow{n})^2)})\\notag\\end{align}$$","link":"/compute-refract-direction/"},{"title":"c++模板检测类型是否为Class","text":"利用成员变量指针的实例化来实现 实现12345678910111213template&lt;typename T&gt;struct TIsClass{private: template&lt;typename U&gt; static uint16 Func( int U::* ); template&lt;typename U&gt; static uint8 Func( ... );public: enum { Value = !__is_union( T ) &amp;&amp; ( sizeof( Func&lt;T&gt;( 0 ) ) == sizeof( uint16 ) ) };}; 原理int U::*为成员变量指针，指向U的int成员变量若U为class或者struct，则该函数可被实例化否则，该函数无法实例化","link":"/cpp-template-check-if-type-is-class/"},{"title":"custom mesh render pass","text":"基础概念 UPrimitiveComponent: 可用于渲染或者物理交互的基类,游戏线程拥有其所有变量和状态 FPrimitiveSceneProxy: UPrimitiveComponent的渲染线程版本 FPrimitiveSceneInfo: UPrimitiveComponent在渲染器的内部状态,与FPrimitiveSceneProxy一一映射 FMeshDrawCommand 保存了在一个特定Pass下绘制一个Mesh所需要知道的所有信息 ShaderBindings: 记录了Shader各个阶段绑定的参数集 VertexStreams: 记录了VertexBuffer相关信息 IndexBuffer: 记录了IndexBuffer相关信息 CachedPipelineId: 用于索引GraphicsPipelineState FMeshBatchFPrimitiveSceneProxy生成FMeshBatch有两个途径 Cache Dynamic 具体由哪个途径生成FMeshBatch通过FPrimitiveSceneProxy::GetViewRelevance决定 StaticMesh来说就是Cache的方式,在Proxy添加到场景时调用DrawStaticElements生成的FMeshBatch被保存在FPrimitiveSceneInfo的StaticMeshes中每帧进行重用直到Proxy从场景中移除 Dynamic的方式将会每帧重建FMeshBatch,适用于粒子这种通过调用GetDynamicElements来生成 MeshProcessor Select Shader Collect Pass Bindings, vertex Factory bindings, material bindings Builds One Or More FMeshDrawCommands From a FMeshBatch AddMeshBatch: 必须重载,根据FMeshBatch生成FMeshDrawCommand 每个Pass都需要实现一个MeshPassProcessor,以DepthRendering为例:通过调用BuildMeshDrawCommands生成MeshDrawCommand MeshDrawCommand如何产生? DynamicMesh的MeshDrawCommand需要每帧产生目前只有FLocalVertexFactoy,即(UStaticComponent)可以被Cached因为其它的VertexFactory需要依赖View来设置Shader Binding Static Relevance FBatchingSPDI::DrawMesh如下: 可见对于StaticMesh而言,MeshBatch可以提前CacheMeshDrawCommand需要根据SupportsCachingMeshDrawCommands确定是否能Cache SupportsCachingMeshDrawCommands如下: 目前只有FLocalVertexFactory支持Cache MeshDrawCommand如果VertexFactory依赖于View,由于View会变,则Shader Bindings需要每帧更新,因此无法Cache MeshDrawCommand Shader Bindings: Pass-Constant uniform buffer, 如ViewUniformBuffer,DepthPassUniformBuffer Vertex Factory Bindings Materail Bindings Primitive Bindings Pass specific bindings which change between draws 目前已知DynamicMesh需要每帧生成MeshDrawCommandStaticMesh根据StaticMeshBatchRelevance决定是否需要重新生成 先看下Cache MeshDrawCommand的过程: CacheMeshDrawCommands的实现如下: 会按PassType存储在Scene::CacheDrawLists[PassType]中 接下来看下如何收集MeshDrawCommand MeshDrawCommand的收集就在ComputeViewVisibility中完成 Static MeshDrawCommand的收集如下: AddCommandsForMesh中会根据bSupportsCachingMeshDrawCommands来决定是否已经Cache好了 需要生成MeshDrawCommand的StaticMeshBatch记录在DynamicBuildRequests中 Dynamic MeshDrawCommand收集 DynamicMesh的MeshBatch需要每帧收集: 然后通过SetupMeshPass将StaticMeshBatch和DynamicMeshBatch转换为MeshDrawCommand 因此生成MeshDrawCommand的大致流程如下: 12345678910111213void ComputeViewVisibility(...){ ... GatherStaticMeshDrawCommandAndUnCachedMeshBatch(...); GatherDynamicMeshBatch(...); for(int viewIndex = 0; viewIndex &lt; Views.Num(); ViewIndex++) { SetupMeshPass(Views[viewIndex], ...) }} 最终这些MeshDrawCommand被存储于FViewInfo::ParallelMeshDrawCommandPasses[PassType]中 MeshDrawCommand如何使用最终通过调用以下语句触发DrawCall 1View.ParallelMeshDrawCommandPasses[MeshPassType].DispatchDraw(nullptr, RHICmdList); custom mesh pass以复制一个简化版的DepthPass为例 添加Pass枚举打开文件MeshPassProcessor.h,修改EMeshPass结构体,如下: 修改GetMeshPassName,如下: 新建文件新增MyTestPassRendering.h,MyTestPassRendering.cpp存至Engine/Source/Runtime/Renderer/Private目录 添加Shader新建文件MyTestVertexShader.usf,存于Engine\\Shaders\\Private目录(照抄的PositionOnlyDepthVertexShader.usf) 修改MyTestPassRendering.h新增类FMyTestVS,如下: 在MyTestPassRendering.cpp中通过IMPLEMENT_MATERIAL_SHADER_TYPE实现材质shaderIMPLEMENT_SHADERPIPELINE_TYPE_VS就是构建一个只有VS的FShaderPipelineType对象 添加MeshPassProcessor AddMeshBatch是必须要重载的函数 然后需要把这个类型的MeshPassProcessor通过以下方式注册到FPassProcessorManager中 这里是把一个函数指针通过FRegisterPassProcessorCreateFunction的构造函数,记录到FPassProcessorManager中 SetupMyTestPassState负责设置渲染状态,这里实现如下: 构造函数实现如下: 构造函数中调用了三个SetUniformBuffer SetViewUniformBuffer: ViewUniformBuffer中包含各种变换矩阵以及计算用的贴图数据等等 SetInstancedViewUniformBuffer: 和ViewUniformBuffer差不多,用于Instance Stereo SetPassUniformBuffer: 包含SceneTexture,如GBuffer,SceneDepthTexture等,便于MaterialGraph和GlobalShader使用 这里我们自己定义一个MyTestPassUniformBuffer: 初始化MyTestPassUniformBuffer: 接下来看AddMeshBatch:做了个Pass Filter这个实现里也没啥东西…调用了Process函数,直接看Process 这个函数就是先做了下Shader Filter,然后生成MeshDrawCommand 调用BuildMeshDrawCommands时,传入了一个参数PassDrawRenderState在构造函数中对PassDrawRenderState设置了三个UniformBuffer因此生成的MeshDrawCommand都是绑定了这三个UniformBuffer的 GetMyTestPassShaders实现Shader Filter: 收集MeshDrawCommand之前讲过了MeshDrawCommand的三个来源,那么生成了MeshDrawCommand之后,还需要确定哪些需要被这个Pass调用 打开SceneVisibility.cpp,修改MarkRelevant():这步是收集Cache过的MeshDrawCommand 修改SceneVisibility.cpp中的ComputeDynamicMeshRelevance:这步是收集Dynamic的MeshDrawCommand 创建RenderTarget打开SceneRenderTargets.h,添加成员MyTestSceneDepthZ: 然后创建RT,修改AllocateDeferredShadingPathRenderTargets 释放时机,修改ReleaseSceneColor,ReleaseAllTargets 以及复制构造函数: 打开SceneRenderTargets.h,在FSceneRenderTargets中添加两个函数: BeginRenderingMyTestPass FinishRenderingMyTestPass 上面定义了一个临时变量FRHIRenderPassInfo RPInfo,这个类型可以设置ColorRT,DepthRT然后通过RHICmdList.BeginRenderPass(RPInfo, TEXT(&quot;PassName&quot;))来绑定RT 渲染在FDeferredShadingSceneRenderer中增加函数RenderMyTestPass,并在MyTestPassRendering.cpp中实现 SetupMyTestPassView如下: 然后找个地方调用一下,比如放在RenderPrePass之后 到这一步只能靠renderdoc这种剖析工具查看渲染 Buffer Visualization修改DeferredShadingCommon.ush的FGbufferData 修改DeferredShadingCommon.ush的DecodeGBufferData 这样就把自定义的值放到FGBufferData里了 修改SceneRenderTargetParameters.h该结构定义了一个变量SceneTexturesStruct,可见SceneRenderTargets.cpp 修改SceneRenderTargets的SetupSceneTetureUniformParameters 在RenderMyTestPass中我们会调用SetupSceneTetureUniformParameters将MyTestSceneDepthZ绑定到SceneTexturesStruct.MyTestTexture上因此,在Shader代码中可通过SceneTexturesStruct.MyTestTexture访问 修改DeferredShadingCommon.ush的GetGBufferDataUint 修改DeferredShadingCommon.ush的GetGBufferData 修改SceneViewFamilyBlackboard.h 修改SceneViewFamilyBlackboard.cpp 修改SceneViewFamilyBlackboard.ush 修改BaseEngine.ini 修改`MaterialExpressionSceneTexture.h 接下来新建一个材质,名为MyTestDepth,放在Engine/Content/BufferVisualization目录下: 效果如下: Reference MeshDrawingPipeline Refactoring the Mesh Drawing Pipeline for Unreal Engine 4.22","link":"/custom-mesh-render-pass/"},{"title":"directx 11 create device and swap chain","text":"Create Device with adapterD3D11CreateDeviceAndSwapChain第一个参数如果传NULL,则以默认Adapter创建如果参数不为NULL,DriverType必须为D3D_DRIVER_TYPE_UNKNOWN DXGI_SWAP_CHAIN_DESC SwapEffectDXGI支持两种模式: BitBlt: DXGI_SWAP_EFFECT_DISCARD,DXGI_SWAP_EFFECT_SEQUENTIAL Flip: DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL,DXGI_SWAP_EFFECT_FLIP_DISCARD Flip不支持MultiSampling DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL:从Win8开始支持DXGI_SWAP_EFFECT_FLIP_DISCARD:从Win10开始支持 Flip比BitBlt效率更高,但是对于需要GDI与DirectX混合显示的程序来说，BitBlt是唯一的选择 当SwapChain使用DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL创建,一次成功的Present将会把BackBuffer0从管线解绑,因此需要重新绑定RenderTarget ReferenceFor flip presentation model swap chains that you create with the DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL value set, a successful presentation results in an unbind of back buffer 0 from the graphics pipeline DXGI Flip Mode If you set the pAdapter parameter to a non-NULL value, you must also set the DriverType parameter to the D3D_DRIVER_TYPE_UNKNOWN value","link":"/directx-11-create-device-and-swap-chain/"},{"title":"github page custom domain name","text":"域名注册登录GoDaddy,选择域名进行购买 DNS解析注册腾讯云,腾讯云可以免费解析域名 添加完之后将会看到解析状态为域名DNS未更改,需要登录GoDaddy修改DNS服务器 域名服务器填写f1g1ns1.dnspod.net,f1g1ns2.dnspod.net 回到腾讯云,解析域名,添加以下两条记录 主机记录 记录类型 线路类型 记录值 TTL @ CNAME 默认 &lt;your github name&gt;.github.io 600 www CNAME 默认 &lt;your github name&gt;.github.io 600 Github Page配置上传一个CNAME文件在Github Page根目录下,其内容为你的域名 hexo每次部署都是将本地文件覆盖远程,因此,需要在本地的source文件夹中存放CNAME文件 1www.&lt;your_domain_name&gt;.com CNAME没有后缀名 More Infos Github怎么绑定自己的域名 Using a custom domain with Github Pages","link":"/github-page-custom-domain-name/"},{"title":"hexo qiniu config","text":"简单来说就是七牛可以用来管理图片,加速访问,标准用户有10G的免费存储空间,超出收费 Github毕竟空间有限,而且国内Github访问慢,所以选用了七牛作为图床 配置七牛空间设置首先注册七牛,实名后有10G的免费空间,不实名也能用,有1G的免费空间 注册完之后,到这个界面创建存储空间 填写存储空间信息 不同的地区存储空间超出免费范围收费不同,仅此而已,自行抉择 存储空间名字随便填,只是方便自己管理 配置qiniuhexo-qiniu-sync安装七牛同步插件,避免手动上传图片至云空间 1$ npm install hexo-qiniu-sync --save 配置说明12345678910111213141516171819202122232425262728293031323334#七牛云存储设置##offline 是否离线. 离线状态将使用本地地址渲染##sync 是否同步##bucket 空间名称.##access_key 上传密钥AccessKey##secret_key 上传密钥SecretKey##secret_file 秘钥文件路径，可以将上述两个属性配置到文件内，防止泄露，json格式。绝对路径相对路径均可##dirPrefix 上传的资源子目录前缀.如设置，需与urlPrefix同步 ##urlPrefix 外链前缀.##up_host 上传服务器路径,如选择华北区域的话配置为http://up-z1.qiniu.com##local_dir 本地目录.##update_exist 是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传)##image/js/css 子参数folder为不同静态资源种类的目录名称，一般不需要改动##image.extend 这是个特殊参数，用于生成缩略图或加水印等操作。具体请参考http://developer.qiniu.com/docs/v6/api/reference/fop/image/ ## 可使用基本图片处理、高级图片处理、图片水印处理这3个接口。例如 ?imageView2/2/w/500 即生成宽度最多500px的缩略图qiniu: offline: false sync: true bucket: blog # secret_file: sec/qn.json or C: access_key: &lt;your access key&gt; secret_key: &lt;your secret key&gt; dirPrefix: resources urlPrefix: http://ozkp9xvc9.bkt.clouddn.com/resources up_host: http(s)://upload-z2.qiniup.com local_dir: source/resources update_exist: true image: folder: images extend: js: folder: js css: folder: css bucket: 创建存储空间时填写的名字 access_key,secret_key: 与七牛云通讯的密钥,参考access key and secret key dirPrefix: 存储空间中的虚拟目录,如上面的配置中,可以认为在存储空间中有一个叫做resources的文件夹 urlPrefix: 外链前缀,图片在七牛云上地址前缀 1urlPrefix = domain_address + &apos;/&apos; + dirPrefix up_host: 上传服务器路径,参考Qiniu upload host local_dir: 本地存放图片的文件夹,如上述配置中为source\\resources hexo-asset-image安装1$ npm install hexo-asset-image --save hexo-asset-image是什么?hexo-asset-image用于简化图片引用,需要开启post_asset_folder 执行hexo new [layout] &lt;title&gt;后将在&lt;title&gt;.md同级建立一个&lt;title&gt;目录 图片放在该目录总,markdown中引用方式为![](demo.png),即可引用&lt;title&gt;目录下的demo.png 为什么改?之所以修改hexo-asset-image是因为hexo-qiniu-sync要求图片引用方式改为如下 123{% qnimg imageFile attr1:value1 attr2:value2 &apos;attr3:value31 value32 value3n&apos; [extend:?imageView2/2/w/600 | normal:yes] %}{% qnjs jsFile attr1:value1 attr2:value2 &apos;attr3:value31 value32 value3n&apos; %}{% qncss cssFile attr1:value1 attr2:value2 &apos;attr3:value31 value32 value3n&apos; %} 而标准的markdown语法为: 1![caption](image path) 改成什么样？我希望使用标准的markdown语法来写文章,最终html中img的src路径为七牛云中的图片外链 怎么改？假设,在source\\resources\\images\\下存放一张图片demo.png 按照之前的配置,该图片的外链地址为config.qiniu.urlPrefix/images/demo.png 标准markdown引用该图片的写法为![](/resources/images/demo.png) 由于config.qiniu.urlPrefix最后一个字段为resources 因此，可以分割路径,判断路径的第一个字段与config.qiniu.urlPrefix最后一个字段是否相同,进行拼接 修改结果node_modules\\hexo-asset-image\\index.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&apos;use strict&apos;;var cheerio = require(&apos;cheerio&apos;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) { return str.split(m, i).join(m).length;}hexo.extend.filter.register(&apos;after_post_render&apos;, function(data){ var config = hexo.config; var link = config.qiniu.urlPrefix; // local actual image folder var toprocess = [&apos;excerpt&apos;, &apos;more&apos;, &apos;content&apos;]; for(var i = 0; i &lt; toprocess.length; i++) { var key = toprocess[i]; var $ = cheerio.load(data[key], { ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false }); $(&apos;img&apos;).each(function() { // For windows style path, we replace &apos;\\&apos; to &apos;/&apos;. var src = $(this).attr(&apos;src&apos;).replace(&apos;\\\\&apos;, &apos;/&apos;); // if the regular expression is satisfied, it is actual url instead of local path. if(!/http[s]*.*|\\/\\/.*/.test(src)) { // For &quot;about&quot; page, the first part of &quot;src&quot; can&apos;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&apos;/&apos;).filter(function(elem){ return elem != &apos;&apos;; }); var srcArray = src.split(&apos;/&apos;).filter(function(elem){ return elem != &apos;&apos;; }); if(linkArray[linkArray.length - 1] == srcArray[0]) { srcArray.shift(); src = srcArray.join(&apos;/&apos;); $(this).attr(&apos;src&apos;, link + &apos;/&apos; + src); } } }); data[key] = $.html(); }}); 由于我只是借用了hexo-asset-image的路径拼接,所以不需要开启post-asset-folder 同步图片 本地调用命令server 1hexo server 本地调用命令sync或sync2 1234hexo synchexo shexo sync2hexo s2 上述四条命令任意一条皆可,更详细的解释参见引用 More Info: hexo-qiniu-sync hexo-asset-image Hexo七牛图床使用 使用七牛为Hexo存储图片等资源","link":"/hexo-qiniu-config/"},{"title":"motion blur","text":"motion blur用于表现速度感.一种很常用的后处理技术 算法描述 根据深度图计算出每个像素的世界空间位置。 用前一帧的view-project矩阵进行变换,得到新的视口位置 根据当前帧与上一帧的视口位置，生成逐像素的速度值 沿着速度方向进行多重采样,结果进行平均 深度图提取物体位置viewport position: $H = (\\frac{x}{w}, \\frac{y}{w}, \\frac{z}{w} , 1)$ world-view-project matrix: M $H \\times M^{-1} = (\\frac{X}{W}, \\frac{Y}{W}, \\frac{Z}{W}, W) = D$ world position: $WorldPos = \\frac{D}{D.w}$ 提取世界空间位置: 1234float2 zOverW = tex2D(depthTexture, texCoord);float4 H = float4(texCoord.x * 2 - 1, (1 - texCoord.y) * 2 - 1 , zOverw , 1);float4 D = mul(H, g_ViewProjectionInverseMatrix);float4 worldPos = D / D.w; 逐像素计算速度 1234float4 currentPos = H;float4 previousPos = mul(worldPos, g_previousViewProjectionMatrix);previousPos /= previousPos.w;float2 velocity = (currentPos - previousPos) / 2.0f; 实现emotion blur沿着速度方向进行多重采样,并最终进行平均,得到最终的像素值 12345678float4 color = tex2D(sceneSampler, texCoord);for(int i = 1; i &lt; g_numSamples; ++i, texCoord += velocity){ float4 currentColor = tex2D(sceneSampler, texCoord); color += currentColor;}float4 finalColor = color / g_numSamples; 动态物体上面的算法考虑的是相机的运动，因此对于静态物体表现的很好 对于动态物体,需要记录物体在场景中的速度,可以单独生成一张速度图 可以通过当前帧与下一帧的view-projection矩阵变换物体,计算viewport的位置差异 屏蔽物体如果想要屏蔽掉场景中的某些物体,以使motion blur不对其起作用 那么可以渲染一张mask纹理或者渲染到颜色图的alpha通道 ReferenceGPU Gems 3 Emotion Blur","link":"/motion-blur/"},{"title":"perlin-noise","text":"算法过程 设置晶格点,如以整数位置为晶格点 为每个晶格点设定一个梯度值 计算当前采样点位于哪些晶格点内部 计算晶格点到采样点的向量,并与晶格点的梯度点乘 将与各个晶格点的计算结果做插值,二维噪声就做个双线性插值 实现1234567891011121314151617181920212223242526float perlin_noise(float2 pos){ // compute lattice point int2 p00 = floor(pos); int2 p01 = p00 + int2(0, 1); int2 p10 = p00 + int2(1, 0); int2 p11 = p00 + int2(1, 1); float2 lerp_factor = pos - p00; float2 gradient00 = compute_gradient(p00); float2 gradient01 = compute_gradient(p01); float2 gradient10 = compute_gradient(p10); float2 gradient11 = compute_gradient(p11); float v00 = dot(pos - (float2)p00, gradient00); float v01 = dot(pos - (float2)p01, gradient01); float v10 = dot(pos - (float2)p10, gradient10); float v11 = dot(pos - (float2)p11, gradient11); float v0 = lerp(v00, v01, lerp_factor.y); float v1 = lerp(v10, v11, lerp_factor.y); float v = lerp(v0, v1, lerp_factor.x); return v;} ReferencePerlin Noise","link":"/perlin-noise/"},{"title":"perspective correction","text":"需求光栅化时,三角形内部的顶点属性是由三个顶点插值而来,因此需满足条件: 屏幕空间的属性可以线性插值 推导图中$P_1$,$P_2$,$P_3$,$P_4$共线,$S_1$,$S_2$,$S_3$,$S_4$是在近平面上的投影点 假设各点坐标如下: $P_1$:($x_1$,$z_1$) $P_2$:($x_2$,$z_2$) $P_3$:($x_3$,$z_3$) $P_4$:($x_4$,$z_4$) $S_1$:($s_1$,$d$) $S_2$:($s_2$,$d$) $S_3$:($s_3$,$d$) $S_4$:($s_4$,$d$) d为近平面的Z值 $S_3$为$S_1$,$S_2$的中点,从图中可见在$P_3$并不在$P_1$,$P_2$的中点 因此,Z值在屏幕空间并不成线性关系,由于需要在屏幕空间插值,我们必须找到一个满足线性关系的量 各点向X轴做垂线,可得到以下关系: $$\\frac{x_1}{s_1} = \\frac{z_1}{d} \\Rightarrow s_1 = \\frac{d \\times x_1}{z_1}$$$$\\frac{x_2}{s_2} = \\frac{z_2}{d} \\Rightarrow s_2 = \\frac{d \\times x_2}{z_2}$$$$\\frac{x_4}{s_4} = \\frac{z_4}{d} \\Rightarrow s_4 = \\frac{d \\times x_4}{z_4}$$ 屏幕空间的属性要满足线性关系,因此:$$s_4 = s_1 \\times (1 - t) + s_2 \\times t$$ $$\\therefore \\frac{d \\times x_4}{z_4} = \\frac{d \\times x_1}{z_1} \\times (1 - t) + \\frac{d \\times x_2}{z_2} \\times t$$$$\\therefore \\frac{x_4}{z_4} = \\frac{x_1}{z_1} \\times (1 - t) + \\frac{x_2}{z_2} \\times t\\tag{1}$$ 设直线方程为:$$a \\times x + b \\times z = c$$ $$\\Rightarrow x = \\frac{c - b \\times z}{a} $$ 代入(1)中: $$\\frac{c - b \\times z_4}{a \\times z_4} = \\frac{c - b \\times z_1}{a \\times z_1}\\times (1 - t) + \\frac{c - b \\times z_2}{a \\times z_2} \\times t$$ $$\\Rightarrow \\frac{c}{a \\times z_4} = \\frac{c}{a \\times z_1} \\times (1 - t) + \\frac{c}{a \\times z_2} \\times t$$ $$\\Rightarrow \\frac{1}{z_4} = \\frac{1}{z_1} \\times (1 - t) + \\frac{1}{z_2} \\times t$$ 可见在屏幕空间$\\frac{1}{z}$满足线性关系 顶点属性插值以颜色插值为例,假设$P_1$处的颜色为$C_1$,$P_2$处的颜色为$C_2$,则: $$\\frac{C_4 - C_1}{C_2 - C_1} = \\frac{z_4 - z_1}{z_2 - z_1}$$ $$\\therefore C_4 = \\frac{(C_2 - C_1)\\times (z_4 - z1)}{z_2 - z_1} + C_1\\tag{2}$$ $$\\because z_4 = \\frac{1}{\\frac{1 - t}{z_1} + \\frac{t}{z_2}} = \\frac{z_1\\times z_2}{z_2 \\times (1 - t) + z_1 \\times t}$$ $$\\because z_4 - z_1 = \\frac{z_1 \\times z_2 - z_1 \\times z_2 \\times (1 - t) - z_1^2 \\times t}{z_2 \\times (1 - t) + z_1 \\times t} = \\frac{z_1\\times t \\times (z_2 - z_1)}{z_2 \\times (1 - t) + z_1 \\times t}$$ $$\\therefore \\frac{z_4 - z_1}{z_2 - z_1} = \\frac{z_1 \\times t}{z_2 \\times (1 - t) + z_1 \\times t}$$ 代入(2)式: $$C_4 = \\frac{(C_2 - C_1)\\times z_1 \\times t}{z_2 \\times (1 - t) + z_1 \\times t} + C_1$$ $$\\Rightarrow C_4 = \\frac{C_2\\times z_1 \\times t + C_1\\times z_2 \\times (1 - t)}{z_2 \\times (1 - t) + z_1 \\times t}$$ $$\\Rightarrow C_4 = \\frac{C_2\\times t \\times \\frac{1}{z_2} + C_1\\times (1 - t) \\times \\frac{1}{z_1}}{\\frac{1-t}{z_1} + \\frac{t}{z_2}}$$ $$\\Rightarrow \\frac{C_4}{z_4} = \\frac{C_2}{z_2}\\times t + \\frac{C_1}{z_1}\\times (1 - t)$$ 透视矩阵推导NDC空间:$$-1 \\leq x \\leq 1$$$$-1 \\leq y \\leq 1$$$$0 \\leq z \\leq 1$$ 根据上图可知:$$\\frac{x}{z} = \\frac{x’}{d} \\Rightarrow x’ = \\frac{d \\times x}{z}\\tag{3}$$$$\\frac{y}{z} = \\frac{y’}{d} \\Rightarrow y’ = \\frac{d \\times y}{z}\\tag{4}$$ 定义宽高比为r $$tan(\\frac{\\alpha}{2}) = \\frac{1}{d} \\Rightarrow d = \\frac{1}{tan(\\frac{\\alpha}{2})}$$$$tan(\\frac{\\beta}{2}) = \\frac{r}{d} = rtan(\\frac{\\alpha}{2})$$ 代入(3),(4)中可得:$$x’ = \\frac{d \\times x}{z} = \\frac{x}{tan(\\frac{\\alpha}{2}) \\times z}$$$$y’ = \\frac{d \\times y}{z} = \\frac{y}{tan(\\frac{\\alpha}{2}) \\times z}$$ $$\\because -1 \\leq y’ \\leq 1, -r \\leq x’ \\leq r$$$$\\Rightarrow -1 \\leq \\frac{y}{tan(\\frac{\\alpha}{2}) \\times z} \\leq 1$$$$\\Rightarrow -1 \\leq \\frac{x}{r \\times tan(\\frac{\\alpha}{2}) \\times z} \\leq 1$$ 我们已知$\\frac{1}{z}$成线性关系,我们希望近平面,远平面深度值分别映射到$[0,1]$,因此,设: $$0 \\leq A \\times \\frac{1}{z} + B \\leq 1$$$$A \\times \\frac{1}{n} + B = 0$$$$A \\times \\frac{1}{f} + B = 1$$ $$\\Rightarrow A = \\frac{-n\\times f}{f - n}, B = \\frac{f}{f - n}$$ $$\\therefore 0 \\leq \\frac{f}{f - n} - \\frac{n \\times f}{f - n} \\times \\frac{1}{z} \\leq 1$$ 因此,透视投影矩阵如下:$$\\begin{bmatrix}\\frac{1}{r\\times tan(\\frac{\\alpha}{2})} &amp; 0 &amp; 0 &amp; 0 \\\\0 &amp; \\frac{1}{tan(\\frac{\\alpha}{2})} &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; \\frac{f}{f - n} &amp; 1 \\\\0 &amp; 0 &amp; \\frac{n\\times f}{n - f} &amp; 0\\end{bmatrix}$$ 逆矩阵如下:$$\\begin{bmatrix}r \\times tan(\\frac{\\alpha}{2}) &amp; 0 &amp; 0 &amp; 0 \\\\0 &amp; tan(\\frac{\\alpha}{2}) &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; 0 &amp; \\frac{n - f}{n\\times f} \\\\0 &amp; 0 &amp; 1 &amp; \\frac{1}{n}\\end{bmatrix}$$ 深度重建还原深度值首先推导下如何从Depth Buffer还原深度值,Depth Buffer存的值为:$Z_{buffer} = \\frac{f}{f - n} - \\frac{n \\times f}{f - n} \\times \\frac{1}{z}$ $$Z_{buffer} \\in [0,1]$$$$\\Rightarrow \\frac{n \\times f}{f - n} \\times \\frac{1}{z} = \\frac{f}{f - n} - Z_{buffer}$$$$\\Rightarrow \\frac{n \\times f}{z} = f - Z_{buffer} \\times (f - n)$$$$\\Rightarrow z = \\frac{n \\times f}{f - Z_{buffer} \\times (f - n)}$$$$\\Rightarrow z = \\frac{1}{\\frac{1}{n} - \\frac{f - n}{n \\times f} Z_{buffer}}$$$$\\Rightarrow z = \\frac{1}{\\frac{1}{n} + \\frac{n - f}{n \\times f} Z_{buffer}}$$$$\\Rightarrow z = \\frac{1}{\\frac{1}{n} + \\frac{1}{f}\\times (1 - \\frac{f}{n}) Z_{buffer}}$$$$z \\in [n, f]$$ CameraSpace重映射深度值为[0,1]将CameraSpace原点映射至0,远平面映射至1$$z_{cs} = \\frac{z}{f} = \\frac{n \\times f}{f - Z_{buffer} \\times (f - n)} \\times \\frac{1}{f}$$$$\\Rightarrow z_{cs} = \\frac{n}{f - Z_{buffer} \\times (f - n)}$$$$\\Rightarrow z_{cs} = \\frac{1}{\\frac{f}{n} + \\frac{n - f}{n} \\times Z_{buffer}}$$$$\\Rightarrow z_{cs} = \\frac{1}{\\frac{f}{n} + (1 - \\frac{f}{n}) \\times Z_{buffer}}$$ Screen Space Ray March假设屏幕空间坐标(x,y),则齐次坐标为($2\\times x - 1$,2 \\times y - 1$)","link":"/perspective-correction/"},{"title":"python 3 UnicodeDecodeError when pip install package","text":"Issue安装python库时报错，UnicodeDecodeError Solution打开python36\\lib\\site-packages\\pip\\compat\\__init__.py 修改console_to_str函数,将编码改为gbk 1return s.decode(&apos;utf-8&apos;) 改为: 1return s.decode(&apos;gbk&apos;) Reason我的路径中含有中文,解码失败后,python默认使用utf-8,然而windows中文应该使用gbk","link":"/python-3-UnicodeDecodeError-when-pip-install-package/"},{"title":"reflect and refraction","text":"反射方向反射定律:$\\theta_i = \\theta_o$ 折射方向折射定律:$\\quad$ $\\eta_i \\sin\\theta_i = \\eta_t sin\\theta_t$ $\\eta_i$: 入射介质折射率 $\\eta_o$: 出射介质折射率 $\\theta_i$: 入射角 $\\theta_o$: 折射角 折射方向计算 折射率与波长相关，因此,在两种不同媒介的交界面入射的自然光将会沿着多个方向散射,即色散 菲涅尔方程当光经过两种不同折射率的界面时,在两者的交界处可能会同时发生光的反射与折射 菲涅尔方程描述了不同光波分量被折射和反射的情况 入射光的功率被界面反射的比例，称之为反射比$R$;折射的比例称之为透射比$T$ 反射比和透射比的具体形式与入射光的偏振有关 垂直偏振光反射比:$$R_\\bot = (\\frac{\\eta_icos\\theta_i - \\eta_tcos\\theta_t}{\\eta_icos\\theta_i + \\eta_t\\cos\\theta_t})^2$$ 平行偏振光反射比:$$R_\\parallel = (\\frac{\\eta_t \\cos\\theta_i - \\eta_i\\cos\\theta_t}{\\eta_t\\cos\\theta_i + \\eta_i\\cos\\theta_t})^2$$ 根据能量守恒,透射比都满足:$T = 1 -R$ 图形学中通常考虑光是无偏振的，也就是偏振是等量的:$R = \\frac{R_{|}+R_{\\bot}}{2}$ 反射和折射光的振幅与入射光的振幅比值通常称之为反射率($r$)和透射率($t$) $$R = r^2 \\quad T = (\\frac{\\eta_t\\cos\\theta_t}{\\eta_1\\cos\\theta_i})t^2$$ 导体不能透射光,但会部分入射光会被吸收转换为热能,常用的导体的菲涅尔方程如下: $$r_|^2 = \\frac{(\\eta^2 + k^2)cos\\theta_i^2 - 2\\eta\\cos\\theta_i + 1}{(\\eta^2 + k^2)cos\\theta_i^2 + 2\\eta\\cos\\theta_i + 1}$$ $$r_\\bot^2 = \\frac{(\\eta^2 + k^2) - 2\\eta\\cos\\theta_i + \\cos\\theta_i^2}{(\\eta^2 + k^2) + 2\\eta\\cos\\theta_i + \\cos\\theta_i^2}$$ 因为导体不能透射光,因此方程中并无透射角与透射面的折射率 BRDF接下来讲讲镜面反射和镜面折射的BRDF 由于菲涅尔方程给出了光被反射的量$F_r(\\omega_o)$,因此： $$L_o(\\omega_r) = \\int f_r(p, \\omega_i, \\omega_r )L_i(\\omega_i)cos(\\theta)d\\omega_i = F_r(\\omega_o)L_i(\\omega_i) = F_r(\\omega_i)L_i(\\omega_i)\\tag{1}$$ $\\omega_o$为$\\omega_i$关于表面法线的反射向量,$\\theta_i = \\theta_o$,因此,$F_r(\\omega_o)=F_r(\\omega_i)$ 该BRDF可以使用脉冲函数进行构造: $$f_r(p , \\omega_o , \\omega_i) = f \\times \\delta(\\omega_i - \\omega_r) = f \\times \\delta(\\cos\\theta_i - \\cos\\theta_r)\\delta(\\phi_i - \\phi_r \\pm \\pi)\\tag{2}$$ 因此: $$L_o(\\theta_o,\\phi_o) = \\int_\\Omega f \\times \\delta(cos\\theta_i - cos\\theta_r) \\delta(\\phi_o - \\phi_r \\pm \\pi) L_i(\\theta_i,\\phi_i)|cos\\theta_i|d\\omega_i = f \\times L_i(\\theta_r,\\phi_r \\pm \\pi)|cos\\theta_i|$$ 结合方程(1): $$L_o(\\omega_o) = f \\times L_i(\\theta_r,\\phi_r \\pm \\pi)|cos\\theta_i| = F_r(\\omega_i)L_i(\\omega_i)$$ $$\\Rightarrow f = \\frac{F_r(\\omega_o)}{|cos\\theta_i|}$$ 结合方程(2): $$\\Rightarrow f_r(p , \\omega_o , \\omega_i) = F_r(\\omega_o)\\frac{\\delta(\\omega_i - R(\\omega_o , n))}{|\\cos\\theta_i|}$$ $R(\\omega_o , n)$为$\\omega_o$关于表面法线的镜面反射方向 此时$L_o(\\theta_o , \\phi_o) = F_r(\\omega_o)L_i(\\theta_r , \\phi_r\\pm \\pi)$ 前面说过了$F_r(\\omega_o)$表示入射光被反射的量 至此，镜面反射的BRDF计算完毕 讲完镜面反射的BRDF，接下来讲讲镜面折射的BRDF 这里我们使用$\\tau = 1 - F_r(\\omega_i)$表示入射能量被折射的量 因此，微分通量可以表示如下: $$d\\Phi_o = \\tau d\\Phi_i$$ $$L_o cos\\theta_o dA d\\omega_o = \\tau(L_i\\cos\\theta_i dAd\\omega_i)$$ 表示为球面坐标如下:$$L_o cos\\theta_o dA \\sin\\theta_o d\\theta_o d\\phi_o = \\tau(L_i\\cos\\theta_idA\\sin\\theta_id\\theta_id\\phi_i)$$ 由于$\\eta_i \\sin\\theta_i = \\eta_o \\sin\\theta_o$ 因此对其求微分可得: $$\\eta_o cos\\theta_o d\\theta_o = \\eta_i\\cos\\theta_id\\theta_i$$ 因此: $$\\frac{cos\\theta_od\\theta_o}{\\cos\\theta_id\\theta_i} = \\frac{\\eta_i}{\\eta_o}$$ 又因为$\\frac{\\sin\\theta_o}{\\sin\\theta_i} = \\frac{\\eta_i}{\\eta_o}$ 因此: $$\\frac{\\sin\\theta_o\\cos\\theta_od\\theta_o}{\\sin\\theta_i\\cos\\theta_id\\theta_i} = \\frac{\\eta_i^2}{\\eta_o^2}$$ 所以 $$L_o\\eta_i^2d\\phi_o = \\tau L_i\\eta_o^2 d\\phi_i$$ 由于$\\phi_i = \\phi_o + \\pi$，因此$d\\phi_i = d\\phi_o$ 所以: $$L_o = \\tau L_i\\frac{\\eta_o^2}{\\eta_i^2}$$ 因此镜面折射的BRDF为: $$f_t(p , \\omega_i , \\omega_o) = \\frac{\\eta_o^2}{\\eta_i^2}(1 - F_r(\\omega_i))\\frac{\\delta(\\omega_i - T(\\omega_o , n))}{|\\cos\\theta_i|}$$ $T(\\omega_o , n)$为$\\omega_o$关于表面法线的镜面折射向量","link":"/reflect-refraction/"},{"title":"shading model","text":"Lambert Model$$I_o = D * I_i\\cos(\\theta)$$ $$D = \\frac{\\rho_d}{\\pi}$$ $\\rho_d$表示表面的反射率：用于描述入射光能量在表面被反射的比例。范围在[0 , 1] $\\theta$为入射光线$L$与法线$n$的夹角 Lambert Model是漫反射模型，在任何出射方向的光能都是一样 因此 $$I_o = \\frac{\\rho_d}{\\pi}I_i\\cos(\\theta)$$ 那么我们对所有的出射光进行积分： $$I_{total-ouput} = \\int_\\Omega \\frac{\\rho_d}{\\pi}I_i\\cos(\\theta)d\\omega$$ $$d\\omega = \\sin(\\theta)d\\theta d\\varphi$$ $$I_{total-ouput} = \\int_0^{2\\pi}d\\varphi\\int_0^{\\frac{\\pi}{2}}I_i\\frac{\\rho_d}{\\pi}\\cos(\\theta)\\sin(\\theta)d\\theta$$ $$I_{total-ouput} = 2\\pi\\frac{\\rho_d}{\\pi}I_i\\int_0^{\\frac{\\pi}{2}}\\frac{\\sin(2\\theta)}{2}d\\theta$$ $$I_{total-ouput} = \\rho_dI_i*(-\\frac{\\cos(2\\theta)}{2})\\mid_0^{\\frac{\\pi}{2}}$$ $$I_{total-ouput} = \\rho_dI_i$$ 与$\\rho_d$的定义一致 Phong Model该模型是个经验模型 $$I_o = k_a I_a + \\sum_{m\\in lights}(k_d(\\overrightarrow{L_m}\\cdot \\overrightarrow{N})I_{m , d}) + \\sum_{m\\in lights}(k_s(\\overrightarrow{R_m} \\cdot \\overrightarrow{V})^{\\alpha}I_{m , s})$$ $k_a$：环境光反射率 $k_d$：漫反射光反射率 $k_s$：镜面光反射率 $\\alpha$：光泽度，该值越大，表面越光滑，高亮区域越小 $I_a$：环境光 $I_d$：光源的漫反射分量 $I_s$：光源的镜面分量 $\\overrightarrow{R}$：反射光方向 $\\overrightarrow{N}$：法线方向 $\\overrightarrow{L}$：光线入射的反方向，通常都是使用入射的反方向 $\\overrightarrow{V}$：指向viewer的方向 该模型由三个分量组成：环境光，漫反射光，镜面光。 环境光部分： $$I_{o , a} = k_a I_a$$ 漫反射部分： $$I_{o , d} = \\sum_{m\\in lights}(k_d(\\overrightarrow{L_m}\\cdot \\overrightarrow{N})I_{m , d})$$ 镜面光部分： $$I_{o , s} = \\sum_{m\\in lights}(k_s(\\overrightarrow{R_m}\\cdot \\overrightarrow{V})^{\\alpha}I_{m , s})$$ Blinn-Phong Model该模型在Phong Model的基础上改进了计算方法 $$H = \\frac{\\overrightarrow{L} + \\overrightarrow{V}}{\\lVert \\overrightarrow{L} + \\overrightarrow{V} \\rVert}$$ 使用$\\overrightarrow{N}\\cdot \\overrightarrow{H_m}$代替$\\overrightarrow{R_m}\\cdot \\overrightarrow{V}$ 因为$\\overrightarrow{N}\\cdot \\overrightarrow{H_m}$可以在一开始就计算好，因此可以加快计算。 $$I_o = k_aI_a + \\sum_{m \\in lights}(k_d(\\overrightarrow{L_m} \\cdot \\overrightarrow{N})I_{m , d}) + \\sum_{m \\in lights}(k_s(\\overrightarrow{N}\\cdot \\overrightarrow{H_m})^{\\alpha}I_{m , s})$$ 环境光分量： $$I_{o , a} = k_a I_a$$ 漫反射分量： $$I_{o , d} = \\sum_{m \\in lights}(k_d(\\overrightarrow{L_m} \\cdot \\overrightarrow{N})I_{m , d})$$ 镜面光分量： $$I_{o , s} = \\sum_{m \\in lights}(k_s(\\overrightarrow{N}\\cdot \\overrightarrow{H_m})^{\\alpha}I_{m , s})$$","link":"/shading-model/"},{"title":"SRT represent's disadvantage","text":"$SRT$是指使用缩放,旋转,平移来表示变换矩阵 SRT表示法矩阵$M$可以使用$SRT$表示: $$\\overrightarrow{v}M = \\overrightarrow{v} SRT = \\overrightarrow{v} SR + \\overrightarrow{T}$$ 非等比缩放考虑如下情况: $$\\begin{align}\\overrightarrow{v_2} &amp;= \\overrightarrow{v_1} M_1\\notag\\\\&amp;= \\overrightarrow{v_0}M_0M_1\\notag\\\\&amp;= \\overrightarrow{v_1}S_1R_1 + \\overrightarrow{T_1}\\notag\\\\&amp;= (\\overrightarrow{v_0}S_0R_0 + \\overrightarrow{T_0})S_1R_1 + \\overrightarrow{T_1}\\notag\\\\&amp;= \\overrightarrow{v_0}(S_0R_0S_1R_1) + (\\overrightarrow{T_0}S_1R_1 + \\overrightarrow{T_1})\\notag\\end{align}$$ 如果我们要将$M_0M_1$表示为$SRT$,那么说明$S_0R_0S_1R_1$可以表示为$SR$ 如果$S_1$为等比缩放,那么$S_0R_0S_1R_1 = S_0S_1R_0R_1$ 那么不是等比缩放呢？ 问题转化为存在正交旋转矩阵$R$与缩放矩阵$S$,则$RS$能否表达为$S^{‘}R^{‘}$? 通过反证法来证明,考虑如下矩阵: $$S =\\begin{bmatrix}1 &amp; 0 &amp; 0 \\\\0 &amp; 2 &amp; 0 \\\\0 &amp; 0 &amp; 1\\end{bmatrix} \\quadR =\\begin{bmatrix}1 &amp; 0 &amp; 0 \\\\0 &amp; \\frac{\\sqrt{2}}{2} &amp; -\\frac{\\sqrt{2}}{2} \\\\0 &amp; \\frac{\\sqrt{2}}{2} &amp; \\frac{\\sqrt{2}}{2}\\end{bmatrix}$$ 假设存在$S’$和$R’$使得$RS=S’R’$ $$\\begin{alignat}{2}R’ &amp;=\\begin{bmatrix}r’{11} &amp; r’{12} &amp; r’{13} \\\\r’{21} &amp; r’{22} &amp; r’{23} \\\\r’{31} &amp; r’{32} &amp; r’_{33}\\end{bmatrix} &amp;\\quadS’ &amp;=\\begin{bmatrix}s’_1 &amp; r0 &amp; 0 \\\\0 &amp; s’_2 &amp; 0 \\\\0 &amp; 0 &amp; s’_3\\end{bmatrix}\\notag\\\\[2ex]RS &amp;=\\begin{bmatrix}1 &amp; 0 &amp; 0 \\\\0 &amp; \\sqrt{2} &amp; -\\frac{\\sqrt{2}}{2} \\\\0 &amp; \\sqrt{2} &amp; \\frac{\\sqrt{2}}{2}\\end{bmatrix} &amp;\\quadS’R’ &amp;=\\begin{bmatrix}s’1r’{11} &amp; s’1r’{12} &amp; s’1r’{13} \\\\s’2r’_{21} &amp; s’2r’{22} &amp; s’2r’{23} \\\\s’3r’_{31} &amp; s’3r’{32} &amp; s’3r’{33}\\end{bmatrix}\\notag\\end{alignat}$$ 结合$RS = S’R’$与$R’$为正交矩阵可得:$$\\begin{cases}1 = s’1 r’{11} \\\\[2ex]0 = s’1 r’{12} \\\\[2ex]0 = s’1 r’{13} \\\\[2ex]r’^2_{11} + r’^2_{12} + r’^2_{13} = 1\\end{cases}$$ $\\therefore s’_1 = \\pm{1}$,同理可得:$s’_2 = \\pm \\frac{\\sqrt{2}\\sqrt{5}}{2}$与$s’_3 = \\pm \\frac{\\sqrt{2}\\sqrt{5}}{2}$ $$\\begin{align}\\because det(AB) &amp;= det(A)det(B) \\quad RS = S’R’ \\quad det(S’) = s’_1s’_2s’_3\\notag\\\\[2ex]\\therefore det(R’) &amp;= \\frac{det(R)det(S)}{det(S’)}\\notag\\\\[2ex]&amp;= \\frac{1\\times (1\\times 2 \\times 1)}{\\pm{1}\\times \\frac{\\sqrt{2}\\sqrt{5}}{2}\\times \\frac{\\sqrt{2}\\sqrt{5}}{2}}\\notag\\\\[2ex]&amp;= \\pm \\frac{4}{5} \\neq 1\\notag\\end{align}$$与$R’$为正交矩阵的假设不符. 分解矩阵为SRT假设某个节点有n个祖先,其局部变换矩阵分别为$M_1,M_2,\\cdots M_n$. $$\\begin{align}M_{SRT} &amp;= M_0M_1\\cdots M_n\\notag\\\\[2ex]M_{RT} &amp;= R_0T_0R_1T_1\\cdots R_nT_n\\notag\\end{align}$$ 从$M_{SRT}$中很容易分解出平移项,提取第四行元素即可 从$M_{RT}$中剥离平移,可以得到$M_R$矩阵,这个矩阵必须被转换为四元数或欧拉角 最麻烦的是提取缩放,首先将$M_{SRT}$中的平移项置零,得到$M_{SR}$. 然后通过如下公式计算缩放矩阵: $$M_S = M_{SR}M_R^{-1}$$ 只需要从该矩阵中提取对角线的元素作为缩放,其余元素是产生倾斜(变形))的部分 More InfoGPU Pro 5 - Managing Transformations in Hierarchy矩阵乘积的行列式等于行列式的乘积插入公式诀窍MathJax语法","link":"/skeleton-customize-SRT-is-not-good-method/"},{"title":"software recommend","text":"该页面用于收集好的工具软件 Cmder 控制台神器 Autohotkey 快捷键神器 Listary 文件检索神器 破解版,正版很便宜,建议正版 Snipaste 贴图软件 Vimium Chrome插件,纯键盘操作 Tampermonkey Chrome脚本管理器插件 可以安装各种用户脚本,比如百度云下载链接转为迅雷下载,VIP视频破解等 Potplayer 最爱的视频播放器,Zone皮肤 xshell 很好用的shell工具 激活码:101210-450789-147200 total commander 神级文件管理器 CCleaner 清理工具 注册码:C2YW-N8ZC-FMC7-AHR9-UZPC Bandzip 解压缩 压缩包内是一个文件夹时就不会再建一个文件夹 OneQuick 热键快捷工具 Typora Markdown编辑器 MathPix 识别图像中的公式并生成对应的Latex FalconX 任务栏透明居中 Office Tool Plus Office激活工具 Process Hacker 进程查看器：查看进程的各种信息，如内存，句柄，环境变量等 SingleFile Chrome静态网页保存插件：可以较为完整的保存静态网页 Rufus 刷系统启动盘工具 ProcDump自动监测应用程序崩溃并自动转储崩溃文件，避免程序崩溃后无法得到现场，安装方式：管理员权限启动CMD 1procdump.exe -ma -i 转储目录 如： 1procdump.exe -ma -i D:\\CrashDump 卸载方式： 1procdump.exe -u ScrcpyWindow上控制Android手机的神器，需开启adb调试 tidevice可用于Windows上与IOS设备通信，可以模拟adb的常规操作 SpaceSniffer直观查看磁盘空间占用情况 DNS Jumper点击最快DNS即可自动检测DNS服务器的解析速度，检测完毕后点击应用即可生效：","link":"/software-recommend/"},{"title":"unity _WorldSpaceLightDir in forwardBase lightMode","text":"现象将方向光的旋转全部设为0，此时方向光朝向+Z,因此方向光的朝向为(0,0,1) 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142Shader &quot;Custom/Test&quot;{ Properties { } SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; struct appdata { float4 pos : POSITION; }; struct v2f { float4 pos : SV_POSITION; float3 worldPos : TEXCOORD1; }; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.pos); o.worldPos = mul(unity_ObjectToWorld, v.pos); return o; } fixed4 frag (v2f i) : SV_Target { return float4(UnityWorldSpaceLightDir(i.worldPos), 1.0f); } ENDCG } }} 此时渲染结果为一个蓝色的鸭子 当加上Tags { &quot;LightMode&quot; = &quot;ForwardBase&quot; }后: 1234567891011121314151617181920212223242526272829303132333435363738394041424344Shader &quot;Custom/Test&quot;{ Properties { } SubShader { Pass { Tags { &quot;LightMode&quot; = &quot;ForwardBase&quot; } CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;UnityCG.cginc&quot; struct appdata { float4 pos : POSITION; }; struct v2f { float4 pos : SV_POSITION; float3 worldPos : TEXCOORD1; }; v2f vert (appdata v) { v2f o; o.pos = UnityObjectToClipPos(v.pos); o.worldPos = mul(unity_ObjectToWorld, v.pos); return o; } fixed4 frag (v2f i) : SV_Target { return float4(UnityWorldSpaceLightDir(i.worldPos), 1.0f); } ENDCG } }} 此时渲染结果为一只黑色的鸭子: 原因用RenderDoc剖析一下,打开ForwardBase时: 关闭ForwardBase后: 可见在设置LightMode为ForwardBase时,CB中传入的光方向发生了反转经过测试，当LightMode为ForwardAdd时,CB中传入的光方向也被反转了","link":"/unity-WorldSpaceLightDir-in-forwardBase-lightMode/"},{"title":"unity surface shader","text":"Flow Code Structure123456789101112131415161718192021222324252627282930Shader &quot;xxx&quot;{ Properties { ... } SubShader { Tags {...} LOD ... CGPROGRAM #pragma surface &lt;Surface Function&gt; &lt;LightingModel&gt; [options] struct &lt;Input Struct&gt; { ... }; UNITY_INSTANCING_BUFFER_START(Props) UNITY_INSTANCING_BUFFER_END(Props) void &lt;surface function name&gt;(&lt;Input Struct&gt; IN, inout &lt;SurfaceOutput&gt; o) { ... } ENDCG } FallBack &quot;Diffuse&quot;} #pragma surface &lt;Surface Function&gt; &lt;LightingModel&gt; [options]中指定了surface函数名以及光照模型光照模型封装好了顶点着色器以及像素着色器,surface函数填充&lt;SurfaceOutput&gt;结构,然后用于光照计算 由于对于确定的光照模型而言,所需的数据以及计算流程都是固定的，因此可以直接封装起来然后将SurfaceOutput的填充交给开发者来做 也可以自己定义顶点着色器,如: 1#pragma surface surf Lambert vertex:vert 指定函数vert为顶点着色器,surf为surface函数,光照模型为Lambert BlinnPhong Surface Analysis示例实现: 123456789101112131415161718192021222324252627282930313233343536373839404142Shader &quot;Custom/SurfaceShaderBlinnPhong&quot; { Properties { _Color (&quot;Color&quot;, Color) = (1,1,1,1) _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {} _SpecColor (&quot;Specular Material Color&quot;, Color) = (1,1,1,1) _Shininess (&quot;Shininess&quot;, Range (0.03, 1)) = 0.078125 } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } LOD 200 CGPROGRAM #pragma surface surf BlinnPhong fullforwardshadows #pragma target 3.0 sampler2D _MainTex; float _Shininess; struct Input { float2 uv_MainTex; }; UNITY_INSTANCING_BUFFER_START(Props) // put more per-instance properties here UNITY_INSTANCING_BUFFER_END(Props) void surf (Input IN, inout SurfaceOutput o) { fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Specular = _Shininess; o.Gloss = c.a; o.Alpha = 1.0f; } ENDCG } FallBack &quot;Diffuse&quot;} BlinnPhong光照模型的实现可以在Lighting.cginc中找到,其中实现了四个函数: LightingBlinnPhong LightingBlinnPhong_Deferred LightingBlinnPhong_GI LightingBlinnPhong_PrePass LightingBlinnPhongLightingBlinnPhong的实现如下: 123456789101112131415161718192021222324252627inline fixed4 UnityBlinnPhongLight (SurfaceOutput s, half3 viewDir, UnityLight light){ half3 h = normalize (light.dir + viewDir); fixed diff = max (0, dot (s.Normal, light.dir)); float nh = max (0, dot (s.Normal, h)); float spec = pow (nh, s.Specular*128.0) * s.Gloss; fixed4 c; c.rgb = s.Albedo * light.color * diff + light.color * _SpecColor.rgb * spec; c.a = s.Alpha; return c;}inline fixed4 LightingBlinnPhong (SurfaceOutput s, half3 viewDir, UnityGI gi){ fixed4 c; c = UnityBlinnPhongLight (s, viewDir, gi.light); #ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT c.rgb += s.Albedo * gi.indirect.diffuse; #endif return c;} 其中SurfaceOutput的定义也可以在Lighting.cginc中找到 123456789struct SurfaceOutput { fixed3 Albedo; fixed3 Normal; fixed3 Emission; half Specular; fixed Gloss; fixed Alpha;}; UnityGI与UnityLight的定义在UnityLightingCommon.cginc中找到: 123456789101112131415161718struct UnityLight{ half3 color; half3 dir; half ndotl; // Deprecated: Ndotl is now calculated on the fly and is no longer stored. Do not used it.};struct UnityIndirect{ half3 diffuse; half3 specular;};struct UnityGI{ UnityLight light; UnityIndirect indirect;};","link":"/unity-surface-shader/"},{"title":"unreal setup.bat speed","text":"修改Setup.bat:","link":"/unreal-setup-bat-speed/"},{"title":"use hexo deploy github page","text":"Create Github PageCreate a new repo named &lt;username&gt;.github.io,&lt;username&gt; is your username on Github Create a new branch named source Setup Hexoinstall Node.jsNode.js install Gitgit install hexo command line interface1$ npm install -g hexo-cli init hexoinit hexo in the target &lt;folder&gt;,such as E\\blog 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install After running the command, a directory named node_modules will be added under the blog root folder. install git deploy tool1$ npm install hexo-deployer-git --save config deploymodify site’s setting in _config.yml 1234deploy: type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master generate and deploy hexo1$ hexo generate -d Manage Hexodeploy tool will sync .deploy_git to master branch while run deploy command but our blog source file does not version control. so, we should upload our blog source file to source branch. Hexo PluginLatex1npm install hexo-math --save latex still can’t work after install hexo-math After installing the plug-in I did not find the hexo-math folder. then i install hexo-renderer-mathjax,don’t add hexo-renderer-mathjax to plugins of _config.yml now i found hexo-math folder under node_modules directory.but still can’t work. open node_modules\\hexo-math\\lib\\option.js 1234567891011121314151617181920212223242526var DEFAULT_OPTS = exports.DEFAULT_OPTS = { engine: &apos;mathjax&apos;, mathjax: { src: &quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js&quot;, config: { tex2jax: { inlineMath: [[&apos;$&apos;, &apos;$&apos;], [&quot;\\\\(&quot;, &quot;\\\\)&quot;]], skipTags: [&apos;script&apos;, &apos;noscript&apos;, &apos;style&apos;, &apos;textarea&apos;, &apos;pre&apos;, &apos;code&apos;], processEscapes: true }, TeX: { equationNumbers: { autoNumber: &quot;AMS&quot; } } } }, katex: { css: &quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;, js: &quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js&quot;, config: { throwOnError: false, errorColor: &quot;#cc0000&quot; } }}; but The official website is described below 1234567891011121314151617181920212223242526const DEFAULT_OPTS = { engine: &apos;mathjax&apos;, mathjax: { src: &quot;//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;, config: { tex2jax: { inlineMath: [ [&apos;$&apos;,&apos;$&apos;], [&quot;\\\\(&quot;,&quot;\\\\)&quot;] ], skipTags: [&apos;script&apos;, &apos;noscript&apos;, &apos;style&apos;, &apos;textarea&apos;, &apos;pre&apos;, &apos;code&apos;], processEscapes: true }, TeX: { equationNumbers: { autoNumber: &quot;AMS&quot; } } } }, katex: { css: &quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css&quot;, js: &quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js&quot;, config: { throwOnError: false, errorColor: &quot;#cc0000&quot; } } } now it work after modify. but still not perfect,hexo-math can’t will parse multi _ tag as Italic. such as: 1$F_{r} = \\frac{r_{\\|}^{2} + r_{\\bot}^{2}}{2}$ Modify the regular expression in file node_modules/marked/lib/marked.js source: 12345678910111213141516171819202122232425262728/** * Inline-Level Grammar */var inline = { escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\\/)[^ &gt;]+)&gt;/, url: noop, tag: /^&lt;!--[\\s\\S]*?--&gt;|^&lt;\\/?\\w+(?:&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;|[^&apos;&quot;&gt;])*?&gt;/, link: /^!?\\[(inside)\\]\\(href\\)/, reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/, nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/, strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/, em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/, br: /^ {2,}\\n(?!\\s*$)/, del: noop, text: /^[\\s\\S]+?(?=[\\\\&lt;!\\[_*`]| {2,}\\n|$)/};/** * Pedantic Inline Grammar */inline.pedantic = merge({}, inline.normal, { strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/, em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/}); target: 12345678910111213141516171819202122232425262728/** * Inline-Level Grammar */var inline = { escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_&gt;])/, autolink: /^&lt;([^ &gt;]+(@|:\\/)[^ &gt;]+)&gt;/, url: noop, tag: /^&lt;!--[\\s\\S]*?--&gt;|^&lt;\\/?\\w+(?:&quot;[^&quot;]*&quot;|&apos;[^&apos;]*&apos;|[^&apos;&quot;&gt;])*?&gt;/, link: /^!?\\[(inside)\\]\\(href\\)/, reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/, nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/, strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/, br: /^ {2,}\\n(?!\\s*$)/, del: noop, text: /^[\\s\\S]+?(?=[\\\\&lt;!\\[_*`]| {2,}\\n|$)/};/** * Pedantic Inline Grammar */inline.pedantic = merge({}, inline.normal, { strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/, em: /^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/}); DisqusDisqus Disqus Configclick GET STARTED, select I want to install Disqus on my site First Step: Second Step: my Platform is hexo , so i select install manually with universal code Next Disqus will show the Universal Code install instructions page Third Step: Website URL is http://&lt;username&gt;.github.io/ Apply DisqusOpen File layout/_partial/article.ejs under theme folder Add this snippet to the end of the file 1234567&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt;&lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt;&lt;/section&gt;&lt;% } %&gt; Open File layout/_partical/after-footer.ejs under theme folder Add this snippet to the file 123456789101112131415&lt;% if (config.disqus_shortname){ %&gt;&lt;script&gt; var disqus_shortname = &apos;&lt;%= config.disqus_shortname %&gt;&apos;; &lt;% if (page.permalink){ %&gt; var disqus_url = &apos;&lt;%= page.permalink %&gt;&apos;; &lt;% } %&gt; (function(){ var dsq = document.createElement(&apos;script&apos;); dsq.type = &apos;text/javascript&apos;; dsq.async = true; dsq.src = &apos;//&apos; + disqus_shortname + &apos;.disqus.com/&lt;% if (page.comments) { %&gt;embed.js&lt;% } else { %&gt;count.js&lt;% } %&gt;&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(dsq); })();&lt;/script&gt;&lt;% } %&gt; modify site’s _config.yml 1disqus_shortname: &lt;shortname&gt; # refer to Website Name in the first step More Info: Create Github Page Setup Hexo Deployment How to config it to make it work 为什么这个公式没法解析 修复Hexo写Mathjax公式多个下标失效的问题 Plugin: hexo math hexo-deploy-git hexo-renderer-mathjax","link":"/use-hexo-deploy-github-page/"},{"title":"visual studio code convert tab to space","text":"使用空格缩进打开VSCode控制面板,选择Indent Using Spaces 显示空格打开VSCode用户设置文件-首选项-设置 增加如下配置: 1&quot;editor.renderWhitespace&quot;: &quot;all&quot;,","link":"/visual-studio-code-convert-tab-to-space/"},{"title":"why Not PI in BRDF implement","text":"案例分析Lambert的BRDF为$\\frac{c_{d}}{\\pi}$,在Unity中,Lambert光照实现为: 123456789101112131415161718192021inline fixed4 UnityLambertLight (SurfaceOutput s, UnityLight light){ fixed diff = max (0, dot (s.Normal, light.dir)); fixed4 c; c.rgb = s.Albedo * light.color * diff; c.a = s.Alpha; return c;}inline fixed4 LightingLambert (SurfaceOutput s, UnityGI gi){ fixed4 c; c = UnityLambertLight (s, gi.light); #ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT c.rgb += s.Albedo * gi.indirect.diffuse; #endif return c;} 可见并没有除$\\pi$ 这里首先介绍一下精确光源(Punctual Light Sources) 精确光源精确光源的定义是无限小,无限亮的光源,如点光源,方向光,聚光灯虽然并非是物理真实的,但是可以产生比较合理的光照结果且计算非常方便精确光源可参数化为关于光源颜色$c_{light}$以及光方向$l_c$的方程 其中$c_{light}$的定义为: 白色Lambert表面被光方向平行于表面法线($l_c$ == n)的光源照亮时的颜色 精确光源主要的好处是极大的简化了反射方程,以下为推导过程 定义一个微面光源,光源中心方向为$l_c$,且光照角度范围为$\\varepsilon$:$$\\forall l|\\angle(l,l_c) &gt; \\varepsilon, \\quad L_{tiny}(l) = 0$$$$if \\quad l_c = n, then \\quad c_{light} = \\int_\\Omega\\frac{1}{\\pi} L_{tiny}(l)(n\\cdot l)d_{\\omega_i}$$ 由于$l_c = n$且$\\varepsilon \\rightarrow 0$,因此可以假定$(n\\cdot l) = 1$ $$\\Rightarrow c_{light} = \\lim_{\\varepsilon \\rightarrow 0}(\\frac{1}{\\pi}\\int_\\Omega L_{tiny}(l)d_{\\omega_i})$$ $$\\Rightarrow \\lim_{\\varepsilon \\rightarrow 0}(\\int_\\Omega L_{tiny}(l)d_{\\omega_i}) = \\pi c_{light}$$ 接下来将其代入通用的BRDF:$$L_o(v) = \\lim_{\\varepsilon \\rightarrow 0}(\\int_\\Omega f(l,v)\\otimes L_{tiny}(l)(n\\cdot l)d_{\\omega_i} = f(l_c,v)\\otimes \\lim_{\\varepsilon \\rightarrow 0}(\\int_\\Omega L_{tiny}(l)d_{\\omega_i})(n\\cdot l_c)$$ $$\\Rightarrow L_o(v) = \\pi f(l_c,v)\\otimes c_{light}(n\\cdot l_c)\\tag{1}$$ 式(1)即为精确光源的反射方程 Lambert光照实现Lambert的BRDF为$\\frac{c_d}{\\pi}$,代入(1)式:$$\\Rightarrow L_o(v) = \\pi \\frac{c_d}{\\pi}\\otimes c_{light}(n \\cdot l_c) = c_d \\otimes c_{light}(n \\cdot l_c)$$ Reference Physically-Based Shading Models in Film and Game Production PI or not to PI in game lighting equation","link":"/why-Not-PI-in-BRDF-implement/"},{"title":"why normal transform use inverse-transpose matrix","text":"定义$T$为切线,$N$为法线,$M$为切线的变换矩阵,$Q$为法线的变换矩阵 证明$$T\\cdot N^T = 0\\\\[2ex]T\\cdot M = T’\\\\[2ex]N\\cdot Q = N’\\\\[2ex]T’\\cdot (N’)^T = 0\\\\[2ex]T\\cdot M \\cdot (N\\cdot Q)^T = 0\\\\[2ex]T\\cdot M \\cdot Q^T \\cdot N^T = 0\\\\[2ex]\\therefore M\\cdot Q^T = I\\\\[2ex]\\therefore Q = (M^{-1})^T$$","link":"/why-normal-transform-use-inverse-transpose-matrix/"},{"title":"","text":"剔除HZB优点：Drawcall少，GPU运算 缺点：过于保守，依赖回读 Hardware Occlusion Query优点：像素级查询 缺点：大量Drawcall Software Occlusion优点：像素级结果 缺点：CPU运算 Visibility Buffer个人想出的猜想性方案，基于HZB改进。HZB的主要问题在于使用CS做保守判断 该方案方法如下： 借助图形管线的光栅化只在可见像素上写入PrimitiveId 回读到CPU后解析可见的PrimitiveId 根据提交HZB的Primitive列表与可见的Primitive列表，算出不可见的Primitive列表 利用光栅化就又带入了Hardware Occlusion Query同样的问题，Drawcall过多，对于非Instanced的Primitive可进行合批 合批图元的Bound的八个顶点数据记录于同一条Buffer 以图元数作为Instance数，标准正方体作为图元发起实例化渲染 VertexBuffer中根据InstanceId以及VertexId存取真实的顶点数据 PrimitiveId作为Instanced Buffer传入 VS中根据InstanceId取出PrimitiveId传入PS并写出 借助图形管线的光栅化流程，便可只有可见像素写出PrimitiveId，发起的Drawcall数量为HISM数+ISM数+1 整体Drawcall数可控，CPU增加些许解析数据开销，优点在于得到更为精细的剔除结果","link":"/剔除/"},{"title":"自定义Hexo博客显示","text":"Hexo结构搭建环境安装NodeJS与Git，新建目录用于存放博客，如下命令皆在博客根目录执行，初始化Hexo： 1hexo init 安装基础组件： 12npm install hexo-cli -gnpm install hexo-deployer-git 安装主题，如Minos： 1git clone https://github.com/ppoffice/hexo-theme-minos.git themes/minos 此时文件夹结构如下所示： node_modules scaffolds source _posts: 存放MD源文件 themes minos(主题名) languages: layout：页面模板文件，控制如何生成页面，使用EJS编写 scripts： source：存放主题使用的css，js，font等 _config.yml：站点配置文件 package.json：在该目录安装的node库及版本号 修改_config.yml中的theme为Minos(前面的主题名)，此时在Git Bash内执行hexo s可预览显示结果 执行npm install可以自动安装package.json中指定的包 自动部署Github Page在Github上新建两个仓库： blog_source：存放博客源文件，草稿等内容，命名随意，此为示意 用户名.github.io：存放最终部署的网页，必须为该格式 生成SSH密钥：执行下列命令后，在.ssh文件夹下将生成id_ed25519与id_ed25519.pub 1ssh-keygen -t ed25519 -C &quot;邮箱&quot; Github Page仓库设置Github Page仓库的搭建：参考文档，以用户名.github.io为仓库名新建公开仓库即可 在用户Settings -&gt; SSH and GPG Keys下添加SSH Keys的公钥，注意是用户而非仓库设置 博客源仓库设置blog_source需要进行如下设置： 上传上一节的目录到Github仓库中 的Settings -&gt;Secrets and variables -&gt;Actions中添加SSH私钥，命名为SSH_DEPLOY_KEY 仓库的根目录添加.github/workflows/deployment.yml，其内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940name: Deploymenton: pushjobs: deployment: runs-on: ubuntu-latest name: Deployment steps: - name: Check Out uses: actions/checkout@v3 - name: Clone Repo uses: actions/checkout@v3 with: repository: lonelyWaiting/lonelyWaiting.github.io.git ref: master path: .deploy_git - name: Setup Node uses: actions/setup-node@v3 with: node-version: 12.14 - name: Setup Git run: | git config --global user.name &quot;lonelyWaiting&quot; git config --global user.email &quot;lonelywaitinggm@gmail.com&quot; - name: Setup SSH Key run: | mkdir -p ~/.ssh echo &quot;${{ secrets.SSH_DEPLOY_KEY }}&quot; &gt; ~/.ssh/id_ed25519 chmod 600 ~/.ssh/id_ed25519 - name: Deploy run: | npm install -g hexo-cli npm install hexo d -g 注意上面的repository填写格式为：Username/RepositoryName，如果仓库名配置错误，会出现类似报错： Github Actions解读自动部署利用的是Github Actions，该功能会自动查找项目下的.github/workflows下的yml文件 每一个yml文件为一个Action，每个Action可以包含多个Step： Checkout: 拉取当前仓库的最新提交 Clone Repo：拉取部署仓库的最新提交 Setup Node：安装指定版本NodeJS Setup Git：设置Git全局用户设置 Setup SSH Key：将仓库中配置的私钥写入到机器的.ssh中，用于后续提交验证 Deploy：安装Hexo必备组件以及执行生成，部署操作 主题配置修改_config.yml的theme项: 1theme: minos 使用Minos时将会出现网页显示德文的情况，需要配置语言项，修改_config.yml的language项为： 1language: zh-cn 启用disqus，_config.yml中配置disqus如下： 123comment: type: disqus shortname: lonelywaiting 添加页面底部链接： 12footer_links: Github: https://github.com/用户名 导航栏添加Github跳转地址： 1234navbar_links: GitHub: icon: fab fa-github url: https://github.com/用户名 _config.yml添加Logo：Logo文件放在根目录/source/，命名为favicon.ico 1logo: /favicon.ico 编辑_config.yml，启用MathJax支持： 12plugins: mathjax: true 使用创建文章：hexo new [layout] &lt;title&gt;，默认layout为Post 创建Post： 1hexo new 文件名 创建页面： 1hexo new page 文件名 创建草稿页面: 1hexo new draft 文件名 发布草稿：注意文件名不包含md后缀 1hexo P 草稿文件名 本地预览: 1hexo s 生成并部署： 1hexo g -d 本机预览草稿： 1hexo s --draft 功能扩展标题自动生成序号添加自定义CSSMinos会自动扫描minos/layout/plugins下的文件并作为插件加载，添加custom.ejs，内容如下： 1&lt;link href=&quot;/css/user.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; 上述代码会加载user.css，在minos/source/css/下添加user.css用于自定义样式表 定义标题序号 counter-reset: 定义计数器并默认设置为0 12345678910111213141516171819202122232425262728body { counter-reset: body; /* 修改正文字体 */ font-family: &quot;Vollkorn&quot;, Palatino, Times; color: #333; line-height: 1.4; text-align: justify;}/* 正文标题自动序号 */h1 { counter-reset: h1;}h2 { counter-reset: h2;}h3 { counter-reset: h3;}h4 { counter-reset: h4;}h5 { counter-reset: h5;}h6 { counter-reset: h6;} 标题前添加序号123456789101112131415161718192021222324h1:before { counter-increment: body; content: counter(body) &quot;. &quot;;}h2:before { counter-increment: h1; content: counter(body) &quot;.&quot; counter(h1) &quot;. &quot;;}h3:before { counter-increment: h2; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2) &quot;. &quot;;}h4:before { counter-increment: h3; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3) &quot;. &quot;;}h5:before { counter-increment: h4; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4) &quot;. &quot;;}h6:before { counter-increment: h5; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4)&quot;.&quot; counter(h5) &quot;. &quot;;} 移除文章标题的序号123456789h1:before { counter-increment: body; content: counter(body) &quot;. &quot;;}/*必须位于h1:before之后，靠后的规则优先级更高*/h1.article-title:before { content: none;} Hover状态下添加序号默认Hover状态下会在标题前添加#并设置其位置，这与序号的添加方案冲突 因此需要重载Hover也自动添加序号，因此2.1.3节修改为如下结果： 123456789101112131415161718192021222324252627282930313233343536h1:before ,.article .article-entry h1:hover:before { counter-increment: body; content: counter(body) &quot;. &quot;; position: unset;}h2:before ,.article .article-entry h2:hover:before { counter-increment: h1; content: counter(body) &quot;.&quot; counter(h1) &quot;. &quot;; position: unset;}h3:before ,.article .article-entry h3:hover:before { counter-increment: h2; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2) &quot;. &quot;; position: unset;}h4:before ,.article .article-entry h4:hover:before { counter-increment: h3; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3) &quot;. &quot;; position: unset;}h5:before ,.article .article-entry h5:hover:before { counter-increment: h4; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4) &quot;. &quot;; position: unset;}h6:before ,.article .article-entry h6:hover:before { counter-increment: h5; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4)&quot;.&quot; counter(h5) &quot;. &quot;; position: unset;} 避免序号跨文章自增在Page页面由于会出现多个文章的预览，但由于前面的计数方案只是以某级标题的数量进行自增 但正确的显示方案是每篇文章都从0开始自增，因此，在遇到文章标题时自动重置计数器： 123h1.article-title { counter-reset: body h1 h2 h3 h4 h5 h6;} 调试方法使用右键–检查元素或者F12可以调试网页，可以选中元素对应的HTML，页面将会显示出其CSS标签，便于在CSS中匹配标签： 以下图为例，鼠标在元素窗口选中标题时，页面中显示了对应的CSS，因此我们可以通过如下标签进行选择： 123h1.article-title:before { content: none} 默认添加ReadMore不添加&lt;!-- more --&gt;时，默认显示全文改为显示Read More链接，文章显示很乱 修改layout/common/article.ejs，找到post.excerpt，修改对应部分如下： 12345678910111213141516171819&lt;div class=&quot;article-entry is-size-6-mobile&quot; itemprop=&quot;articleBody&quot;&gt; &lt;% if (post.excerpt &amp;&amp; index){ %&gt; &lt;%- post.excerpt %&gt; &lt;p class=&quot;article-more-link&quot;&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;#more&quot;&gt;&lt;%= __(&apos;article.read_more&apos;) %&gt;&lt;/a&gt; &lt;/p&gt; &lt;% } else { %&gt; &lt;!-- 以下为原值 --&gt; &lt;!-- &lt;%- post.content %&gt; --&gt; &lt;!-- 以下为修改结果 --&gt; &lt;% if (index) { %&gt; &lt;p class=&quot;article-more-link&quot;&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;#more&quot;&gt;&lt;%= __(&apos;article.read_more&apos;) %&gt;&lt;/a&gt; &lt;/p&gt; &lt;% } else { %&gt; &lt;%- post.content %&gt; &lt;% } %&gt; &lt;% } %&gt; &lt;/div&gt; 可在_config.yml中配置article的read_more，即可修改链接显示文字，默认为Read More： 12article: read_more: Read More 添加文章目录在themes/minos/layout/下新建inject目录，并在其中新建toc.ejs，其实现如下： 12345&lt;% if (!index &amp;&amp; has_config(&apos;toc&apos;) &amp;&amp; get_config(&apos;toc&apos;) &amp;&amp; typeof(page.content) !== &apos;undefined&apos;) { %&gt; &lt;div class=&quot;toc-title is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only toc&quot;&gt; &lt;%- toc(post.content, {list_number: false}) %&gt; &lt;/div&gt;&lt;% } %&gt; toc()为Hexo提供的辅助函数，用于生成文章目录，list_number用于控制是否生成列表序号 由于只希望在Article页面创建目录，因此需要在Article.ejs中引用该EJS，在Article.ejs的content前添加即可： 1&lt;%- partial(&apos;inject/toc&apos;) %&gt; 最终EJS如下： 1234567891011121314151617&lt;div class=&quot;article-entry is-size-6-mobile&quot; itemprop=&quot;articleBody&quot;&gt;&lt;% if (post.excerpt &amp;&amp; index){ %&gt; &lt;%- post.excerpt %&gt; &lt;p class=&quot;article-more-link&quot;&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;#more&quot;&gt;&lt;%= __(&apos;article.read_more&apos;) %&gt;&lt;/a&gt; &lt;/p&gt;&lt;% } else { %&gt; &lt;% if (index) { %&gt; &lt;p class=&quot;article-more-link&quot;&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;#more&quot;&gt;&lt;%= __(&apos;article.read_more&apos;) %&gt;&lt;/a&gt; &lt;/p&gt; &lt;% } else { %&gt; &lt;%- partial(&apos;inject/toc&apos;) %&gt; &lt;%- post.content %&gt; &lt;% } %&gt;&lt;% } %&gt;&lt;/div&gt; 此时打开文章便可在页面顶部看到目录显示了。但是还需要为目录添加标题序号支持，以及期望与文章的序号单独计数 目录对应的HTML代码如下所示： 因此，我们可以通过使用toc-item.toc-level-1等匹配各级目录 首先匹配class为toc的标签，设置目录位于页面的左侧，位置采用fixed，取消list-style，并定义计数器toc-body为0 123456789.toc { left: 0%; top: 5%; position: fixed; margin: 5px; list-style: none; counter-reset: toc-body; background-color: #fafafa;} 若不取消list-style，每一级目录结构都会按照1~N的形式递增，如： 目录1 子目录1 子目录2 子目录3 目录2 子目录1 子目录2 另外匹配各级目录标签并定义计数器： 123456789101112131415161718192021222324.toc-item.toc-level-1 { counter-reset: toc-level-1; list-style: none;}.toc-item.toc-level-2 { counter-reset: toc-level-2; list-style: none;}.toc-item.toc-level-3 { counter-reset: toc-level-3; list-style: none;}.toc-item.toc-level-4 { counter-reset: toc-level-4; list-style: none;}.toc-item.toc-level-5 { counter-reset: toc-level-5; list-style: none;}.toc-item.toc-level-6 { counter-reset: toc-level-6; list-style: none;} 在目录前生成序号内容： 123456789101112131415161718192021222324.toc-item.toc-level-1:before { counter-increment: toc-body; content: counter(toc-body) &quot;. &quot;;}.toc-item.toc-level-2:before { counter-increment: toc-level-1; content: counter(toc-body) &quot;. &quot; counter(toc-level-1) &quot;. &quot;;}.toc-item.toc-level-3:before { counter-increment: toc-level-2; content: counter(toc-body) &quot;. &quot; counter(toc-level-1) &quot;. &quot; counter(toc-level-2) &quot;. &quot;;}.toc-item.toc-level-4:before { counter-increment: toc-level-3; content: counter(toc-body) &quot;. &quot; counter(toc-level-1) &quot;. &quot; counter(toc-level-2) &quot;. &quot; counter(toc-level-3) &quot;. &quot;;}.toc-item.toc-level-5:before { counter-increment: toc-level-4; content: counter(toc-body) &quot;. &quot; counter(toc-level-1) &quot;. &quot; counter(toc-level-2) &quot;. &quot; counter(toc-level-3) &quot;. &quot; counter(toc-level-4) &quot;. &quot;;}.toc-item.toc-level-6:before { counter-increment: toc-level-5; content: counter(toc-body) &quot;. &quot; counter(toc-level-1) &quot;. &quot; counter(toc-level-2) &quot;. &quot; counter(toc-level-3) &quot;. &quot; counter(toc-level-4) &quot;. &quot; counter(toc-level-5) &quot;. &quot;;} 此时效果： 但当页面宽度不足时，会出现内容与目录重叠的现象： 对此，可以通过修改目录的max-width来实现目录显示区域的收缩，修改themes/minos/source/js/script.js，添加如下代码： 1234567891011121314151617const sectionDiv = $(&apos;.section&apos;)[0];const resizeObserver = new ResizeObserver(entries =&gt; { for (let entry of entries) { if (entry.target === sectionDiv) { const contentDiv = $(&apos;.article.content.gallery&apos;); const contentWidth = parseInt($(contentDiv).css(&apos;width&apos;)); const leftPadding = parseInt($(sectionDiv).css(&apos;padding-left&apos;)); const tocPadding = 24; var maxToWidth = (sectionDiv.offsetWidth - contentWidth) / 2 - leftPadding - tocPadding; if (maxToWidth &lt; 0) maxToWidth = 0; $(&apos;.toc&apos;).css(&apos;max-width&apos;, maxToWidth + &apos;px&apos;); } }});resizeObserver.observe(sectionDiv); window的resize事件无法正确处理该情况，因为resize时某些属性的计算可能还未完成，取到的数据不可信 此时当页面宽度不足时，目录与文章内容无交叠但目录的文字会Wrap，可通过css将其修改为截断+滚动条的形式： 12345.toc { text-overflow: ellipsis; white-space: nowrap; overflow: auto;} 最终页面宽度不足时的效果为： 一键回到顶部/底部出于便捷的目的添加此功能，首先在Themes/minos/layout/inject下新建fast-scroll.ejs，内容如下： 1234567891011121314&lt;% if (has_config(&apos;fast-scroll&apos;) &amp;&amp; get_config(&apos;fast-scroll&apos;) &amp;&amp; typeof(page.content) !== &apos;undefined&apos;) { %&gt;&lt;div id=&quot;fast-scroll&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;button id=&quot;scroll-to-top&quot; class=&quot;fast-btn btn-top&quot; aria-label=&quot;Scroll to top&quot; style=&quot;right: 67.5px; bottom: 120px; display: inline-block;&quot;&gt; &lt;i class=&quot;fas fa-arrow-up&quot;&gt; &lt;/button&gt; &lt;/a&gt; &lt;a href=&quot;#footer&quot;&gt; &lt;button id=&quot;scroll-to-down&quot; class=&quot;fast-btn btn-down&quot; aria-label=&quot;Scroll to down&quot; style=&quot;right: 67.5px; bottom: 60px; display: inline-block;&quot;&gt; &lt;i class=&quot;fas fa-arrow-down&quot;&gt; &lt;/button&gt; &lt;/a&gt;&lt;/div&gt;&lt;% } %&gt; 上述代码添加了两个href用于跳转页面顶部(#)与底部(#footer)，并在链接下各自创建了一个按钮，以及向上与向下的图标。 接下来在footer.ejs中调用上述代码即可，将其添加与footer.ejs的底部即可，如下所示： 123456&lt;footer class=&quot;footer&quot; id=&quot;footer&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 省略原有代码 --&gt; &lt;/div&gt; &lt;%- partial(&apos;inject/fast-scroll&apos;) %&gt;&lt;/footer&gt; 另外需要注意的是，这里为footer元素添加了id=&quot;footer&quot;，用于fast-scroll.ejs中通过href跳转至footer 前面fast-scroll.ejs中指定了按钮的位置，接下来在css中详细定义其样式，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455.fast-btn { background-color: #fff; color: rgb(33, 37, 41); border-bottom-color: rgb(255, 255, 255); border-bottom-left-radius: 50%; border-bottom-right-radius: 50%; border-bottom-style: solid; border-bottom-width: 1px; border-image-outset: 0; border-image-repeat: stretch; border-image-slice: 100%; border-image-source: none; border-image-width: 1; border-left-color: rgba(0, 0, 0, 0); border-left-style: solid; border-left-width: 1px; border-right-color: rgba(0, 0, 0, 0); border-right-style: solid; border-right-width: 1px; border-top-color: rgba(0, 0, 0, 0); border-top-left-radius: 50%; border-top-right-radius: 50%; border-top-style: solid; border-top-width: 1px; box-shadow: rgba(0, 0, 0, 0.3) 0px 2px 5px 0px; box-sizing: border-box; line-height: 24px; position: fixed; font-size: 16px; font-weight: 400; outline-color: rgb(33,37,41); outline-style: none; outline-width: 0px; padding-bottom: 6px; padding-left: 12px; padding-right: 12px; padding-top: 6px; text-shadow: none;}.fast-btn:hover { border-left-color: rgb(0, 0, 0); border-right-color: rgb(0, 0, 0); border-top-color: rgb(0, 0, 0); border-bottom-color: rgb(0, 0, 0);}.fast-btn:active { border-left-color: rgb(0, 0, 0); border-right-color: rgb(0, 0, 0); border-top-color: rgb(0, 0, 0); border-bottom-color: rgb(0, 0, 0); background-color: rgb(0,0,0); color: white;} 最后在themes/minos/_config.yml中开启该功能，即可看到最终效果： 1fast-scroll: true 最终表现效果为：上述CSS中还定义了hover与active状态下的样式，这里不做展示 博客与笔记整合本地使用Typora作为Markdown编辑器，为了与最终的显示不形成过大差异，同样对Typora进行定制: Typora结构Typora提供了多种主题配置，可以通过自定义CSS进行样式定制，其CSS加载规则为： 因此，可以在C:\\Users\\用户名\\AppData\\Roaming\\Typora\\themes下新建/修改base.user.css进行样式定制 但并非所有的功能仅依靠CSS就能完成，需要修改HTML结构才能做到。 这种就需要修改C:\\Program Files\\Typora\\resources\\window.html才能实现，后续插件便是基于此 标题自动序号与Hexo不同的是，Typora的样式表改造只需要专注于文章本身，不涉及显示多个文章的概览等情况。 在Hexo中会使用文章名在网页中作为标题进行显示，然而Typora却默认不会，因此这里不对首个h1标题特殊处理 首先定义各级标题的计数器： 123456789101112131415161718192021222324252627282930body { counter-reset: body; /* 修改正文字体 */ font-family: &quot;Vollkorn&quot;, Palatino, Times; color: #333; line-height: 1.4; text-align: justify;}/* 正文标题自动序号 */h1 { counter-reset: h1;}h2 { counter-reset: h2;}h3 { counter-reset: h3;}h4 { counter-reset: h4;}h5 { counter-reset: h5;}h6 { counter-reset: h6;} 然后在各级标题前添加序号： 123456789101112131415161718192021222324h1:before { counter-increment: body; content: counter(body) &quot;. &quot;;}h2:before { counter-increment: h1; content: counter(body) &quot;.&quot; counter(h1) &quot;. &quot;;}h3:before { counter-increment: h2; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2) &quot;. &quot;;}h4:before { counter-increment: h3; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3) &quot;. &quot;;}h5:before { counter-increment: h4; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4) &quot;. &quot;;}h6:before { counter-increment: h5; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4)&quot;.&quot; counter(h5) &quot;. &quot;;} 此时重启Typora便可看到自动编号的标题了 侧边大纲自动序号方法与文章内标题一致，首先定义计数器： 1234567891011121314151617181920212223.sidebar-content { counter-reset: h1} .outline-h1 { counter-reset: h2} .outline-h2 { counter-reset: h3} .outline-h3 { counter-reset: h4} .outline-h4 { counter-reset: h5} .outline-h5 { counter-reset: h6} 在各级标题前生成序号内容： 1234567891011121314151617181920212223242526272829.outline-h1&gt;.outline-item&gt;.outline-label:before { counter-increment: h1; content: counter(h1) &quot;. &quot;} .outline-h2&gt;.outline-item&gt;.outline-label:before { counter-increment: h2; content: counter(h1) &quot;.&quot; counter(h2) &quot;. &quot;} .outline-h3&gt;.outline-item&gt;.outline-label:before { counter-increment: h3; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;. &quot;} .outline-h4&gt;.outline-item&gt;.outline-label:before { counter-increment: h4; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;. &quot;} .outline-h5&gt;.outline-item&gt;.outline-label:before { counter-increment: h5; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;. &quot;} .outline-h6&gt;.outline-item&gt;.outline-label:before { counter-increment: h6; content: counter(h1) &quot;.&quot; counter(h2) &quot;.&quot; counter(h3) &quot;.&quot; counter(h4) &quot;.&quot; counter(h5) &quot;.&quot; counter(h6) &quot;. &quot;} TOC自动序号Typora支持插入内容目录功能，该功能虽目前不再需要，但为了功能的完备，这里对其兼容 首先依然是根据其HTML标签定义计数器： 123456789101112131415161718192021222324252627282930/* TOC 自动序号 */.md-toc-inner { text-decoration: none;}.md-toc-content { counter-reset: h1toc}.md-toc-h1 { margin-left: 0; counter-reset: h2toc}.md-toc-h2 { margin-left: 1rem; counter-reset: h3toc}.md-toc-h3 { margin-left: 2rem; counter-reset: h4toc}.md-toc-h4 { margin-left: 3rem; counter-reset: h5toc}.md-toc-h5 { margin-left: 4rem; counter-reset: h6toc}.md-toc-h6 { margin-left: 5rem;} 在插入的目录前也生成序号内容： 123456789101112131415161718192021222324.md-toc-h1:before { counter-increment: h1toc; content: counter(h1toc) &quot; &quot;}.md-toc-h2:before { counter-increment: h2toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot;}.md-toc-h3:before { counter-increment: h3toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot;}.md-toc-h4:before { counter-increment: h4toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot;}.md-toc-h5:before { counter-increment: h5toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot;}.md-toc-h6:before { counter-increment: h6toc; content: counter(h1toc) &quot;. &quot; counter(h2toc) &quot;. &quot; counter(h3toc) &quot;. &quot; counter(h4toc) &quot;. &quot; counter(h5toc) &quot;. &quot; counter(h6toc) &quot;. &quot;} 出于美观，调整各级标题的边间距： 123456789101112131415161718.md-toc-h1 .md-toc-inner { margin-left: 0;}.md-toc-h2 .md-toc-inner { margin-left: 0;}.md-toc-h3 .md-toc-inner { margin-left: 0;}.md-toc-h4 .md-toc-inner { margin-left: 0;}.md-toc-h5 .md-toc-inner { margin-left: 0;}.md-toc-h6 .md-toc-inner { margin-left: 0;} 解决H3序号消失编辑h3及以后的标题时，会出现序号消失的情况。原因为base.control.css中定义了包含md-focus的标题样式表： 其重载了h3:md-focus:before的content以及其它属性，从上图可以看出，h4，h5，h6都受到影响 这里不直接修改base.control.css，依然在base.user.css中重载对应标签： 1234567891011121314151617181920212223242526272829303132333435h3.md-focus:before { counter-increment: h2; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2) &quot;. &quot;;}h4.md-focus:before { counter-increment: h3; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3) &quot;. &quot;;}h5.md-focus:before { counter-increment: h4; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4) &quot;. &quot;;}h6.md-focus:before { counter-increment: h5; content: counter(body) &quot;.&quot; counter(h1)&quot;.&quot; counter(h2)&quot;.&quot; counter(h3)&quot;.&quot; counter(h4)&quot;.&quot; counter(h5) &quot;. &quot;;}h3.md-focus:before,h4.md-focus:before,h5.md-focus:before,h6.md-focus:before { color: #333; border: unset; border-radius: unset; position: unset; left: unset; top: unset; float: unset; font-size: unset; padding-left: unset; padding-right: unset; vertical-align: unset; font-weight: unset; line-height: unset;} 资源引用路径一致性使用Hexo时，发布的文章是放置于source/_posts下，对于未发布的文章，可以利用Hexo提供的草稿功能。 将其放置于source/_drafts，待编辑完成后通过命令或手动移至_posts下即可发布。 因此，为了文件移动路径后资源引用正确，资源路径统一放置于source/resources/下 source/resources/images：存放文章引用的图片资源 利用定义Typora的图像插入操作，可以避免编写MD时手动处理图片存放路径的问题： Typora插件修改Typora安装目录下的Window.html，使其引用指定目录下的Javascript文件实现自定义功能 Github上的Typora插件项目便是以这种方式进行实现的： 直接删除插件文件夹内的JS文件，即可按需删除不需要的功能，建议移除以下功能： window_tab old_window_tab auto_number file_counter resize_table resize_image commander export_enhance 插件添加方法：打开Window.html，搜索下列二者之一： 123&lt;script src=&quot;./app/window/frame.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;或&lt;script src=&quot;./appsrc/window/frame.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt; 在其后添加 1&lt;script src=&quot;./plugin/index.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt; 参考资料Github Actions自动部署Hexo博客 Typora插件 创建Github Page站点 Hexo添加文章目录 Hexo添加回到顶部按钮","link":"/自定义Hexo博客显示/"}],"tags":[{"name":"Rendering","slug":"Rendering","link":"/tags/Rendering/"},{"name":"D3D","slug":"D3D","link":"/tags/D3D/"},{"name":"Debug, Tool","slug":"Debug-Tool","link":"/tags/Debug-Tool/"},{"name":"Debug","slug":"Debug","link":"/tags/Debug/"},{"name":"VPS","slug":"VPS","link":"/tags/VPS/"},{"name":"rendering","slug":"rendering","link":"/tags/rendering/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"Unreal","slug":"Unreal","link":"/tags/Unreal/"},{"name":"directx11","slug":"directx11","link":"/tags/directx11/"},{"name":"Noise","slug":"Noise","link":"/tags/Noise/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"software","slug":"software","link":"/tags/software/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"Hexo, Blog","slug":"Hexo-Blog","link":"/tags/Hexo-Blog/"}],"categories":[{"name":"Tool","slug":"Tool","link":"/categories/Tool/"},{"name":"Rendering","slug":"Rendering","link":"/categories/Rendering/"},{"name":"Debug","slug":"Debug","link":"/categories/Debug/"},{"name":"c++","slug":"c","link":"/categories/c/"},{"name":"directx11","slug":"directx11","link":"/categories/directx11/"},{"name":"python","slug":"python","link":"/categories/python/"},{"name":"Unity","slug":"Unity","link":"/categories/Unity/"},{"name":"software","slug":"software","link":"/categories/software/"}]}