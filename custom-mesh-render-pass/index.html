<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>custom mesh render pass - lonelyWaiting</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="基础概念 UPrimitiveComponent: 可用于渲染或者物理交互的基类,游戏线程拥有其所有变量和状态 FPrimitiveSceneProxy: UPrimitiveComponent的渲染线程版本 FPrimitiveSceneInfo: UPrimitiveComponent在渲染器的内部状态,与FPri">
<meta name="keywords" content="Unreal">
<meta property="og:type" content="article">
<meta property="og:title" content="custom mesh render pass">
<meta property="og:url" content="http://lonelywaiting.github.io/custom-mesh-render-pass/index.html">
<meta property="og:site_name" content="lonelyWaiting">
<meta property="og:description" content="基础概念 UPrimitiveComponent: 可用于渲染或者物理交互的基类,游戏线程拥有其所有变量和状态 FPrimitiveSceneProxy: UPrimitiveComponent的渲染线程版本 FPrimitiveSceneInfo: UPrimitiveComponent在渲染器的内部状态,与FPrimitiveSceneProxy一一映射">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/FMeshDrawCommand.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/FMeshBatch.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/MeshBatchGeneratePath.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/StaticGenerateMeshBatch.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/DynamicGenerateMeshBatch.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/FMeshPassProcessor.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/DepthPass_AddMeshBatch.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/DepthPass_Process.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/CacheMeshDrawCommand.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/Cache_MeshBatch.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/DrawMesh_SupportCacheMeshDrawCommand.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/SupportsCachingMeshDrawCommands.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/CacheGenerateMeshDrawCommand.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/CacheMeshDrawCommands.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/GatherMeshDrawCommand.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/Gather_StaticMeshDrawCommand.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/AddCommandsForMesh.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/DynamicGenerateMeshBatch.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/AddMeshPassEnum.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/GetMeshPassName.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/MyTestVertexShader.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/MyTestVS.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/IMPLEMENT_MATERIAL_SAHDER.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/MyTestPassMeshProcessor.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/RegisterPassProcessorCreateFunction.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/SetupDepthPassState.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/FMyTestPassMeshProcessorConstructor.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/DefineMyTestPassUniformBuffer.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/InitMyTestPassUniformBuffer.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/AddMeshBatch.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/Process.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/GetMyTestPassShaders.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/MarkRelevant.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/ComputeDynamicMeshRelevance.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/MyTestSceneDepthZ.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/AllocateMyTestDepth.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/ReleaseMyTestDepthZ.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/RTCopyConstructor.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/BindRTDeclaration.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/BindMyTestPass.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/RenderMyTestPass.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/SetupMyTestPassView.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/InvokeRenderMyTestPass.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/FGBufferData.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/DecodeGBufferData.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/SceneTextureStruct.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/SetupSceneTextureUniformParameters.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/GetGBufferDataUint.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/GetGBufferData.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/SceneViewFamilyBlackboard_Declaration.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/Register_MyTestSceneDepthZ.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/SceneViewFamilyBlackboard_Modify.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/BaseEngine_InI.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/MaterialSlot.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/MyTestDepth.png">
<meta property="og:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/BufferVisualization.png">
<meta property="og:updated_time" content="2019-04-19T15:15:08.723Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="custom mesh render pass">
<meta name="twitter:description" content="基础概念 UPrimitiveComponent: 可用于渲染或者物理交互的基类,游戏线程拥有其所有变量和状态 FPrimitiveSceneProxy: UPrimitiveComponent的渲染线程版本 FPrimitiveSceneInfo: UPrimitiveComponent在渲染器的内部状态,与FPrimitiveSceneProxy一一映射">
<meta name="twitter:image" content="http://lonelywaiting.github.io/resources/images/MeshDrawingPipeline/FMeshDrawCommand.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">lonelywaiting</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://lonelywaiting.github.io"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-custom-mesh-render-pass" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      custom mesh render pass
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/custom-mesh-render-pass/" class="article-date">
  <time datetime="2019-04-13T15:12:32.000Z" itemprop="datePublished">2019-04-13</time>
</a>
      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><ul>
<li>UPrimitiveComponent: 可用于渲染或者物理交互的基类,游戏线程拥有其所有变量和状态</li>
<li>FPrimitiveSceneProxy: <code>UPrimitiveComponent</code>的渲染线程版本</li>
<li>FPrimitiveSceneInfo: <code>UPrimitiveComponent</code>在渲染器的内部状态,与<code>FPrimitiveSceneProxy</code>一一映射<a id="more"></a>
<h1 id="FMeshDrawCommand"><a href="#FMeshDrawCommand" class="headerlink" title="FMeshDrawCommand"></a>FMeshDrawCommand</h1></li>
</ul>
<p>保存了在一个特定<code>Pass</code>下绘制一个<code>Mesh</code>所需要知道的所有信息</p>
<p><img src="../resources/images/MeshDrawingPipeline/FMeshDrawCommand.png" alt="MeshDrawCommand"></p>
<ul>
<li>ShaderBindings: 记录了<code>Shader</code>各个阶段绑定的参数集</li>
<li>VertexStreams:  记录了<code>VertexBuffer</code>相关信息</li>
<li>IndexBuffer:    记录了<code>IndexBuffer</code>相关信息</li>
<li>CachedPipelineId: 用于索引GraphicsPipelineState</li>
</ul>
<h1 id="FMeshBatch"><a href="#FMeshBatch" class="headerlink" title="FMeshBatch"></a>FMeshBatch</h1><p><img src="../resources/images/MeshDrawingPipeline/FMeshBatch.png" alt="FMeshBatch"><br><code>FPrimitiveSceneProxy</code>生成<code>FMeshBatch</code>有两个途径</p>
<ul>
<li>Cache</li>
<li>Dynamic</li>
</ul>
<p>具体由哪个途径生成<code>FMeshBatch</code>通过<code>FPrimitiveSceneProxy::GetViewRelevance</code>决定</p>
<p><img src="../resources/images/MeshDrawingPipeline/MeshBatchGeneratePath.png" alt="橙色表示每帧都执行,蓝色表示只执行一次然后被Cache"></p>
<p><code>StaticMesh</code>来说就是<code>Cache</code>的方式,在<code>Proxy</code>添加到场景时调用<code>DrawStaticElements</code><br>生成的<code>FMeshBatch</code>被保存在<code>FPrimitiveSceneInfo</code>的<code>StaticMeshes</code>中<br>每帧进行重用直到<code>Proxy</code>从场景中移除<br><img src="../resources/images/MeshDrawingPipeline/StaticGenerateMeshBatch.png" alt="Cache Path"></p>
<p><code>Dynamic</code>的方式将会每帧重建<code>FMeshBatch</code>,适用于粒子这种<br>通过调用<code>GetDynamicElements</code>来生成<br><img src="../resources/images/MeshDrawingPipeline/DynamicGenerateMeshBatch.png" alt="Dynamic Path"></p>
<h1 id="MeshProcessor"><a href="#MeshProcessor" class="headerlink" title="MeshProcessor"></a>MeshProcessor</h1><ul>
<li>Select Shader</li>
<li>Collect Pass Bindings, vertex Factory bindings, material bindings</li>
<li>Builds One Or More FMeshDrawCommands From a FMeshBatch</li>
</ul>
<p><img src="../resources/images/MeshDrawingPipeline/FMeshPassProcessor.png" alt="FMeshPassProcessor"></p>
<ul>
<li>AddMeshBatch: 必须重载,根据<code>FMeshBatch</code>生成<code>FMeshDrawCommand</code></li>
</ul>
<p>每个Pass都需要实现一个<code>MeshPassProcessor</code>,以<code>DepthRendering</code>为例:<br><img src="../resources/images/MeshDrawingPipeline/DepthPass_AddMeshBatch.png" alt="DepthPass AddMeshBatch"><br>通过调用<code>BuildMeshDrawCommands</code>生成<code>MeshDrawCommand</code><br><img src="../resources/images/MeshDrawingPipeline/DepthPass_Process.png" alt="DepthPass BuildMeshDrawCommand"></p>
<h1 id="MeshDrawCommand如何产生"><a href="#MeshDrawCommand如何产生" class="headerlink" title="MeshDrawCommand如何产生?"></a>MeshDrawCommand如何产生?</h1><p><img src="../resources/images/MeshDrawingPipeline/CacheMeshDrawCommand.png" alt="Cached Mesh Draw Command"></p>
<p><code>DynamicMesh</code>的<code>MeshDrawCommand</code>需要每帧产生<br>目前只有<code>FLocalVertexFactoy</code>,即(<code>UStaticComponent</code>)可以被<code>Cached</code><br>因为其它的<code>VertexFactory</code>需要依赖<code>View</code>来设置<code>Shader Binding</code></p>
<ul>
<li>Static Relevance</li>
</ul>
<p><img src="../resources/images/MeshDrawingPipeline/Cache_MeshBatch.png" alt="Static MeshBatch Cache Flow"></p>
<p><code>FBatchingSPDI::DrawMesh</code>如下:<br><img src="../resources/images/MeshDrawingPipeline/DrawMesh_SupportCacheMeshDrawCommand.png" alt="生成MeshBatch,并确定是否支持Cache为MeshDrawCommand"></p>
<p>可见对于<code>StaticMesh</code>而言,<code>MeshBatch</code>可以提前Cache<br><code>MeshDrawCommand</code>需要根据<code>SupportsCachingMeshDrawCommands</code>确定是否能<code>Cache</code></p>
<p><code>SupportsCachingMeshDrawCommands</code>如下:<br><img src="../resources/images/MeshDrawingPipeline/SupportsCachingMeshDrawCommands.png" alt="SupportsCachingMeshDrawCommands"></p>
<p>目前只有<code>FLocalVertexFactory</code>支持Cache <code>MeshDrawCommand</code><br>如果<code>VertexFactory</code>依赖于<code>View</code>,由于<code>View</code>会变,则<code>Shader Bindings</code>需要每帧更新,因此无法Cache <code>MeshDrawCommand</code></p>
<p>Shader Bindings:</p>
<ul>
<li>Pass-Constant uniform buffer, 如<code>ViewUniformBuffer</code>,<code>DepthPassUniformBuffer</code></li>
<li>Vertex Factory Bindings</li>
<li>Materail Bindings</li>
<li>Primitive Bindings</li>
<li>Pass specific bindings which change between draws</li>
</ul>
<p>目前已知<code>DynamicMesh</code>需要每帧生成<code>MeshDrawCommand</code><br><code>StaticMesh</code>根据<code>StaticMeshBatchRelevance</code>决定是否需要重新生成</p>
<p>先看下Cache <code>MeshDrawCommand</code>的过程:<br><img src="../resources/images/MeshDrawingPipeline/CacheGenerateMeshDrawCommand.png" alt="Cache Generate MeshDrawCommand"></p>
<p><code>CacheMeshDrawCommands</code>的实现如下:<br><img src="../resources/images/MeshDrawingPipeline/CacheMeshDrawCommands.png" alt="CacheMeshDrawCommands"></p>
<p>会按<code>PassType</code>存储在<code>Scene::CacheDrawLists[PassType]</code>中</p>
<p>接下来看下如何收集<code>MeshDrawCommand</code><br><img src="../resources/images/MeshDrawingPipeline/GatherMeshDrawCommand.png" alt="Gather MeshDrawCommand"></p>
<p><code>MeshDrawCommand</code>的收集就在<code>ComputeViewVisibility</code>中完成</p>
<ul>
<li>Static MeshDrawCommand的收集如下:<br><img src="../resources/images/MeshDrawingPipeline/Gather_StaticMeshDrawCommand.png" alt="Gather Static MeshDrawCommand"></li>
</ul>
<p><code>AddCommandsForMesh</code>中会根据<code>bSupportsCachingMeshDrawCommands</code>来决定是否已经<code>Cache</code>好了<br><img src="../resources/images/MeshDrawingPipeline/AddCommandsForMesh.png" alt="AddCommandsForMesh"></p>
<p>需要生成<code>MeshDrawCommand</code>的<code>StaticMeshBatch</code>记录在<code>DynamicBuildRequests</code>中</p>
<ul>
<li>Dynamic MeshDrawCommand收集</li>
</ul>
<p>DynamicMesh的<code>MeshBatch</code>需要每帧收集:<br><img src="../resources/images/MeshDrawingPipeline/DynamicGenerateMeshBatch.png" alt="Dynamic Path"></p>
<p>然后通过<code>SetupMeshPass</code>将<code>StaticMeshBatch</code>和<code>DynamicMeshBatch</code>转换为<code>MeshDrawCommand</code></p>
<p>因此生成<code>MeshDrawCommand</code>的大致流程如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputeViewVisibility</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    GatherStaticMeshDrawCommandAndUnCachedMeshBatch(...);</span><br><span class="line"></span><br><span class="line">    GatherDynamicMeshBatch(...);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> viewIndex = <span class="number">0</span>; viewIndex &lt; Views.Num(); ViewIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        SetupMeshPass(Views[viewIndex], ...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终这些<code>MeshDrawCommand</code>被存储于<code>FViewInfo::ParallelMeshDrawCommandPasses[PassType]</code>中</p>
<h1 id="MeshDrawCommand如何使用"><a href="#MeshDrawCommand如何使用" class="headerlink" title="MeshDrawCommand如何使用"></a>MeshDrawCommand如何使用</h1><p>最终通过调用以下语句触发<code>DrawCall</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View.ParallelMeshDrawCommandPasses[MeshPassType].DispatchDraw(nullptr, RHICmdList);</span><br></pre></td></tr></table></figure></p>
<h1 id="custom-mesh-pass"><a href="#custom-mesh-pass" class="headerlink" title="custom mesh pass"></a>custom mesh pass</h1><p>以复制一个简化版的<code>DepthPass</code>为例</p>
<h2 id="添加Pass枚举"><a href="#添加Pass枚举" class="headerlink" title="添加Pass枚举"></a>添加Pass枚举</h2><p>打开文件MeshPassProcessor.h,修改<code>EMeshPass</code>结构体,如下:<br><img src="../resources/images/MeshDrawingPipeline/AddMeshPassEnum.png" alt="Modify MeshPass Enum"></p>
<p>修改<code>GetMeshPassName</code>,如下:<br><img src="../resources/images/MeshDrawingPipeline/GetMeshPassName.png" alt="Modify GetMeshPassName"></p>
<h2 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h2><p>新增<code>MyTestPassRendering.h</code>,<code>MyTestPassRendering.cpp</code><br>存至<code>Engine/Source/Runtime/Renderer/Private</code>目录</p>
<h2 id="添加Shader"><a href="#添加Shader" class="headerlink" title="添加Shader"></a>添加Shader</h2><p>新建文件<code>MyTestVertexShader.usf</code>,存于<code>Engine\Shaders\Private</code>目录<br><img src="../resources/images/MeshDrawingPipeline/MyTestVertexShader.png" alt="MyTestVertexShader"><br>(照抄的PositionOnlyDepthVertexShader.usf)</p>
<h2 id="修改MyTestPassRendering-h"><a href="#修改MyTestPassRendering-h" class="headerlink" title="修改MyTestPassRendering.h"></a>修改<code>MyTestPassRendering.h</code></h2><p>新增类<code>FMyTestVS</code>,如下:<br><img src="../resources/images/MeshDrawingPipeline/MyTestVS.png" alt="MyTestVS"></p>
<p>在<code>MyTestPassRendering.cpp</code>中通过<code>IMPLEMENT_MATERIAL_SHADER_TYPE</code>实现材质shader<br><img src="../resources/images/MeshDrawingPipeline/IMPLEMENT_MATERIAL_SAHDER.png" alt="Implement Material Shader"><br><code>IMPLEMENT_SHADERPIPELINE_TYPE_VS</code>就是构建一个只有<code>VS</code>的<code>FShaderPipelineType</code>对象</p>
<h2 id="添加MeshPassProcessor"><a href="#添加MeshPassProcessor" class="headerlink" title="添加MeshPassProcessor"></a>添加<code>MeshPassProcessor</code></h2><p><img src="../resources/images/MeshDrawingPipeline/MyTestPassMeshProcessor.png" alt="FMyTestPassMeshProcessor"></p>
<p><code>AddMeshBatch</code>是必须要重载的函数</p>
<p>然后需要把这个类型的<code>MeshPassProcessor</code>通过以下方式注册到<code>FPassProcessorManager</code>中<br><img src="../resources/images/MeshDrawingPipeline/RegisterPassProcessorCreateFunction.png" alt="Register PassProcessor Create Function"></p>
<p>这里是把一个函数指针通过<code>FRegisterPassProcessorCreateFunction</code>的构造函数,记录到<code>FPassProcessorManager</code>中</p>
<p><code>SetupMyTestPassState</code>负责设置渲染状态,这里实现如下:<br><img src="../resources/images/MeshDrawingPipeline/SetupDepthPassState.png" alt="SetupMeshPassState"></p>
<p>构造函数实现如下:<br><img src="../resources/images/MeshDrawingPipeline/FMyTestPassMeshProcessorConstructor.png" alt="FMyTestPassMeshProcessor Constructor"></p>
<p>构造函数中调用了三个<code>SetUniformBuffer</code></p>
<ul>
<li>SetViewUniformBuffer: ViewUniformBuffer中包含各种变换矩阵以及计算用的贴图数据等等</li>
<li>SetInstancedViewUniformBuffer: 和ViewUniformBuffer差不多,用于<code>Instance Stereo</code></li>
<li>SetPassUniformBuffer: 包含SceneTexture,如GBuffer,SceneDepthTexture等,便于<code>MaterialGraph</code>和<code>GlobalShader</code>使用</li>
</ul>
<p>这里我们自己定义一个<code>MyTestPassUniformBuffer</code>:<br><img src="../resources/images/MeshDrawingPipeline/DefineMyTestPassUniformBuffer.png" alt="Define MyTestPassUniformBuffer"></p>
<p>初始化<code>MyTestPassUniformBuffer</code>:<br><img src="../resources/images/MeshDrawingPipeline/InitMyTestPassUniformBuffer.png" alt="InitMyTestPassUniformBuffer"></p>
<p>接下来看<code>AddMeshBatch</code>:<br><img src="../resources/images/MeshDrawingPipeline/AddMeshBatch.png" alt="AddMeshBatch"><br>做了个<code>Pass Filter</code><br>这个实现里也没啥东西…调用了<code>Process</code>函数,直接看<code>Process</code><br><img src="../resources/images/MeshDrawingPipeline/Process.png" alt="Process"></p>
<p>这个函数就是先做了下<code>Shader Filter</code>,然后生成<code>MeshDrawCommand</code></p>
<p>调用<code>BuildMeshDrawCommands</code>时,传入了一个参数<code>PassDrawRenderState</code><br>在构造函数中对<code>PassDrawRenderState</code>设置了三个<code>UniformBuffer</code><br>因此生成的<code>MeshDrawCommand</code>都是绑定了这三个<code>UniformBuffer</code>的</p>
<p><code>GetMyTestPassShaders</code>实现<code>Shader Filter</code>:<br><img src="../resources/images/MeshDrawingPipeline/GetMyTestPassShaders.png" alt="GetMyTestPassShaders"></p>
<h2 id="收集MeshDrawCommand"><a href="#收集MeshDrawCommand" class="headerlink" title="收集MeshDrawCommand"></a>收集MeshDrawCommand</h2><p>之前讲过了<code>MeshDrawCommand</code>的三个来源,那么生成了<code>MeshDrawCommand</code>之后,还需要确定哪些需要被这个Pass调用</p>
<p>打开<code>SceneVisibility.cpp</code>,修改<code>MarkRelevant()</code>:<br><img src="../resources/images/MeshDrawingPipeline/MarkRelevant.png" alt="MarkRelevant"><br>这步是收集Cache过的<code>MeshDrawCommand</code></p>
<p>修改<code>SceneVisibility.cpp</code>中的<code>ComputeDynamicMeshRelevance</code>:<br><img src="../resources/images/MeshDrawingPipeline/ComputeDynamicMeshRelevance.png" alt="ComputeDynamicMeshRelevance"><br>这步是收集Dynamic的<code>MeshDrawCommand</code></p>
<h2 id="创建RenderTarget"><a href="#创建RenderTarget" class="headerlink" title="创建RenderTarget"></a>创建<code>RenderTarget</code></h2><p>打开<code>SceneRenderTargets.h</code>,添加成员<code>MyTestSceneDepthZ</code>:<br><img src="../resources/images/MeshDrawingPipeline/MyTestSceneDepthZ.png" alt="MyTestSceneDepthZ"></p>
<p>然后创建RT,修改<code>AllocateDeferredShadingPathRenderTargets</code><br><img src="../resources/images/MeshDrawingPipeline/AllocateMyTestDepth.png" alt="Allocate MyTestSceneDepthZ"></p>
<p>释放时机,修改<code>ReleaseSceneColor</code>,<code>ReleaseAllTargets</code><br><img src="../resources/images/MeshDrawingPipeline/ReleaseMyTestDepthZ.png" alt="Release MyTestSceneDepthZ"></p>
<p>以及复制构造函数:<br><img src="../resources/images/MeshDrawingPipeline/RTCopyConstructor.png" alt="MyTestSceneDepthZ Copy Constructor"></p>
<p>打开<code>SceneRenderTargets.h</code>,在<code>FSceneRenderTargets</code>中添加两个函数:</p>
<ul>
<li>BeginRenderingMyTestPass</li>
<li>FinishRenderingMyTestPass<br><img src="../resources/images/MeshDrawingPipeline/BindRTDeclaration.png" alt="Function Declaration"><br><img src="../resources/images/MeshDrawingPipeline/BindMyTestPass.png" alt="MyTestPass Bind RT"></li>
</ul>
<p>上面定义了一个临时变量<code>FRHIRenderPassInfo RPInfo</code>,这个类型可以设置<code>ColorRT</code>,<code>DepthRT</code><br>然后通过<code>RHICmdList.BeginRenderPass(RPInfo, TEXT(&quot;PassName&quot;))</code>来绑定RT</p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>在<code>FDeferredShadingSceneRenderer</code>中增加函数<code>RenderMyTestPass</code>,并在<code>MyTestPassRendering.cpp</code>中实现<br><img src="../resources/images/MeshDrawingPipeline/RenderMyTestPass.png" alt="RenderMyTestPass"></p>
<p><code>SetupMyTestPassView</code>如下:<br><img src="../resources/images/MeshDrawingPipeline/SetupMyTestPassView.png" alt="SetupMyTestPassView"></p>
<p>然后找个地方调用一下,比如放在<code>RenderPrePass</code>之后<br><img src="../resources/images/MeshDrawingPipeline/InvokeRenderMyTestPass.png" alt="Invoke RenderMyTestPass"></p>
<p>到这一步只能靠renderdoc这种剖析工具查看渲染</p>
<h1 id="Buffer-Visualization"><a href="#Buffer-Visualization" class="headerlink" title="Buffer Visualization"></a>Buffer Visualization</h1><p>修改<code>DeferredShadingCommon.ush</code>的<code>FGbufferData</code><br><img src="../resources/images/MeshDrawingPipeline/FGBufferData.png" alt="FGBufferData"></p>
<p>修改<code>DeferredShadingCommon.ush</code>的<code>DecodeGBufferData</code><br><img src="../resources/images/MeshDrawingPipeline/DecodeGBufferData.png" alt="DecodeGBufferData"></p>
<p>这样就把自定义的值放到<code>FGBufferData</code>里了</p>
<p>修改<code>SceneRenderTargetParameters.h</code><br><img src="../resources/images/MeshDrawingPipeline/SceneTextureStruct.png" alt="SceneTextureStruct"><br>该结构定义了一个变量<code>SceneTexturesStruct</code>,可见<code>SceneRenderTargets.cpp</code></p>
<p>修改<code>SceneRenderTargets</code>的<code>SetupSceneTetureUniformParameters</code><br><img src="../resources/images/MeshDrawingPipeline/SetupSceneTextureUniformParameters.png" alt="SetupSceneTextureUniformParameters"></p>
<p>在<code>RenderMyTestPass</code>中我们会调用<code>SetupSceneTetureUniformParameters</code><br>将<code>MyTestSceneDepthZ</code>绑定到<code>SceneTexturesStruct.MyTestTexture</code>上<br>因此,在<code>Shader</code>代码中可通过<code>SceneTexturesStruct.MyTestTexture</code>访问</p>
<p>修改<code>DeferredShadingCommon.ush</code>的<code>GetGBufferDataUint</code><br><img src="../resources/images/MeshDrawingPipeline/GetGBufferDataUint.png" alt="GetGBufferDataUint"></p>
<p>修改<code>DeferredShadingCommon.ush</code>的<code>GetGBufferData</code><br><img src="../resources/images/MeshDrawingPipeline/GetGBufferData.png" alt="GetGBufferData"></p>
<p>修改<code>SceneViewFamilyBlackboard.h</code><br><img src="../resources/images/MeshDrawingPipeline/SceneViewFamilyBlackboard_Declaration.png" alt="Modify FSceneViewFamilyBlackboard"></p>
<p>修改<code>SceneViewFamilyBlackboard.cpp</code><br><img src="../resources/images/MeshDrawingPipeline/Register_MyTestSceneDepthZ.png" alt="Register MyTestSceneDepthZ"></p>
<p>修改<code>SceneViewFamilyBlackboard.ush</code><br><img src="../resources/images/MeshDrawingPipeline/SceneViewFamilyBlackboard_Modify.png" alt="Modify SceneViewFamilyBlackboard.ush"></p>
<p>修改<code>BaseEngine.ini</code><br><img src="../resources/images/MeshDrawingPipeline/BaseEngine_InI.png" alt="Add Config"></p>
<p>修改`MaterialExpressionSceneTexture.h</p>
<p><img src="../resources/images/MeshDrawingPipeline/MaterialSlot.png" alt="Add MaterialEditor InputSlot"></p>
<p>接下来新建一个材质,名为<code>MyTestDepth</code>,放在<code>Engine/Content/BufferVisualization</code>目录下:<br><img src="../resources/images/MeshDrawingPipeline/MyTestDepth.png" alt="MyTestDepth"></p>
<p>效果如下:<br><img src="../resources/images/MeshDrawingPipeline/BufferVisualization.png" alt="BufferVisualization"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://docs.unrealengine.com/en-us/Programming/Rendering/MeshDrawingPipeline" target="_blank" rel="noopener">MeshDrawingPipeline</a></li>
<li><a href="https://www.youtube.com/watch?v=qx1c190aGhs&amp;feature=youtu.be" target="_blank" rel="noopener">Refactoring the Mesh Drawing Pipeline for Unreal Engine 4.22</a></li>
</ul>

      
    </div>
    
      <div class="article-toc">
        <h3>Contents</h3>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础概念"><span class="toc-number">1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FMeshDrawCommand"><span class="toc-number">2.</span> <span class="toc-text">FMeshDrawCommand</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FMeshBatch"><span class="toc-number">3.</span> <span class="toc-text">FMeshBatch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MeshProcessor"><span class="toc-number">4.</span> <span class="toc-text">MeshProcessor</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MeshDrawCommand如何产生"><span class="toc-number">5.</span> <span class="toc-text">MeshDrawCommand如何产生?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MeshDrawCommand如何使用"><span class="toc-number">6.</span> <span class="toc-text">MeshDrawCommand如何使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#custom-mesh-pass"><span class="toc-number">7.</span> <span class="toc-text">custom mesh pass</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#添加Pass枚举"><span class="toc-number">7.1.</span> <span class="toc-text">添加Pass枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新建文件"><span class="toc-number">7.2.</span> <span class="toc-text">新建文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加Shader"><span class="toc-number">7.3.</span> <span class="toc-text">添加Shader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改MyTestPassRendering-h"><span class="toc-number">7.4.</span> <span class="toc-text">修改MyTestPassRendering.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#添加MeshPassProcessor"><span class="toc-number">7.5.</span> <span class="toc-text">添加MeshPassProcessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#收集MeshDrawCommand"><span class="toc-number">7.6.</span> <span class="toc-text">收集MeshDrawCommand</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建RenderTarget"><span class="toc-number">7.7.</span> <span class="toc-text">创建RenderTarget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染"><span class="toc-number">7.8.</span> <span class="toc-text">渲染</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Buffer-Visualization"><span class="toc-number">8.</span> <span class="toc-text">Buffer Visualization</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">9.</span> <span class="toc-text">Reference</span></a></li></ol>
      </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unreal/">Unreal</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/perlin-noise/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          perlin-noise
        
      </div>
    </a>
  
  
    <a href="/unreal-setup-bat-speed/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">unreal setup.bat speed&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>






<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>


</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Liuteng
    </div>
  </div>
</footer>
    
<script>
  var disqus_shortname = 'lonelywaiting';
  
  var disqus_url = 'http://lonelywaiting.github.io/custom-mesh-render-pass/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>